const __vite__mapDeps=(i,m=__vite__mapDeps,d=(m.f||(m.f=["assets/geometryEngineJSON-B_JiqPb-.js","assets/geometryEngineBase-BQTefT4Y.js","assets/_commonjsHelpers-DCkdB7M8.js","assets/intersectsOperator-BXc1n3Vv.js","assets/OperatorIntersects-BL2Lbo4f.js","assets/ProjectionTransformation-ZaNkMXqk.js","assets/Envelope2D-DdeZvC4f.js","assets/Point2D-D6cTW4Xl.js","assets/Transformation2D-CiTBrf8G.js","assets/SimpleGeometryCursor-B92kdZ15.js","assets/index-FjkLmFqq.js","assets/index-ClKQjglF.css","assets/OperatorDefinitions-DP7_WWTp.js","assets/jsonConverter-CfmUaf1e.js","assets/containsOperator-BIK4PhY4.js","assets/crossesOperator-Bvq7usl4.js","assets/OperatorCrosses-fCXasOEM.js","assets/disjointOperator-BRtutiqd.js","assets/overlapsOperator-BTVgS_LM.js","assets/OperatorOverlaps-U1seiptg.js","assets/touchesOperator-B557H-V1.js","assets/OperatorTouches-Dh2sfaDT.js","assets/withinOperator-843dE_mc.js","assets/OperatorWithin-BRO8wMHp.js"])))=>i.map(i=>d[i]);
import{vD as nt,vE as me,vF as lt,vG as ot,vH as ut,vI as ye,vJ as ct,hg as ie,s as v,hc as be,vK as pe,vL as ge,bj as W,bm as ke,hj as L,cz as G,hl as Ae,hk as le,vM as $e,_ as D,vN as dt,uK as Ee,vO as ht,vP as ft,c7 as X,hd as mt,bq as ae,vQ as yt,vR as pt,d5 as Fe,vS as Ve,d4 as Se,vT as gt,vU as xt,hK as _t,bU as K,cW as oe,c$ as Ft,h4 as St,ev as It,a2 as Me,ap as wt,vV as V,c as Tt,fZ as Ge,cp as Qe,le as Rt,li as vt,bX as bt,lg as At,mj as $t,mk as Et,iI as Vt,h6 as Mt,mg as ze,d7 as Gt,a$ as Qt}from"./index-FjkLmFqq.js";import{WhereClauseCache as zt}from"./WhereClauseCache-jR_IIW2i.js";import{c as C,m as Pt,n as Dt,a as Bt,b as Nt,h as q,s as qt,f as re,S as O,x as Ot,B as Ct,w as Pe,M as Zt}from"./FixedIntervalBinParameters-B19j63ia.js";import{t as jt}from"./QueryEngineCapabilities-DJC_YILC.js";import{b as kt}from"./utils-y9RzPtOJ.js";import{m as ue,B as Ht,d as Lt,f as De,p as Be,C as Ut,k as Jt,$ as Yt,E as Wt,P as Xt,U as Kt,g as ei,v as ti,L as ii,G as Ne}from"./utils-DFOr-FiE.js";import{e as si,t as qe}from"./SnappingCandidate-DGkpYqI6.js";const Oe=new ie,ai=new ie,xe=new ie,ce={esriGeometryPoint:ye,esriGeometryPolyline:ut,esriGeometryPolygon:ot,esriGeometryMultipoint:lt};function de(n,e,t,i=n.hasZ,s=n.hasM){if(e==null)return null;const a=n.hasZ&&i,r=n.hasM&&s;if(t){const l=me(xe,e,n.hasZ,n.hasM,"esriGeometryPoint",t,i,s);return ye(l,a,r)}return ye(e,a,r)}function Q(n,e,t,i,s,a,r=e,l=t){const o=e&&r,u=t&&l,c=i!=null?"coords"in i?i:i.geometry:null;if(c==null)return null;if(s){let d=nt(ai,c,e,t,n,s,r,l);return a&&(d=me(xe,d,o,u,n,a)),ce[n]?.(d,o,u)??null}if(a){const d=me(xe,c,e,t,n,a,r,l);return ce[n]?.(d,o,u)??null}return ct(Oe,c,e,t,r,l),ce[n]?.(Oe,o,u)??null}function ee(n){return n&&He in n?JSON.parse(JSON.stringify(n,ri)):n}const He="_geVersion",ri=(n,e)=>n===He?void 0:e,Le=new zt(50,500),te="unsupported-query",Ue=" as ",Je=new Set(["esriFieldTypeOID","esriFieldTypeSmallInteger","esriFieldTypeBigInteger","esriFieldTypeInteger","esriFieldTypeSingle","esriFieldTypeDouble","esriFieldTypeLong"]),Ye=new Set(["esriFieldTypeDate","esriFieldTypeDateOnly","esriFieldTypeTimeOnly","esriFieldTypeTimestampOffset"]),ni=new Set(["esriFieldTypeString","esriFieldTypeGUID","esriFieldTypeGlobalID",...Je,...Ye]);function Ie(n,e,t={}){const i=Z(e,n);if(!i){const a=Le.getError(e,n);throw new v(te,"invalid SQL expression",{expression:e,error:a})}const s=t.expressionName||"expression";if(t.validateStandardized&&!i.isStandardized)throw new v(te,`${s} is not standard`,{expression:e});if(t.validateAggregate&&!i.isAggregate)throw new v(te,`${s} does not contain a valid aggregate function`,{expression:e});return i.fieldNames}function li(n,e,t,i){if(!t)return!0;const s="where clause";return B(n,e,Ie(n,t,{validateStandardized:!0,expressionName:s}),{expressionName:s,query:i}),!0}function oi(n,e,t,i,s){if(!t)return!0;const a="having clause",r=Ie(n,t,{validateAggregate:!0,expressionName:a});if(B(n,e,r,{expressionName:a,query:s}),!Z(t,n)?.getExpressions().every(u=>{const{aggregateType:c,field:d}=u,h=n.get(d)?.name;return i.some(m=>{const{onStatisticField:f,statisticType:y}=m;return n.get(f)?.name===h&&y.toLowerCase().trim()===c})}))throw new v(te,"expressions in having clause should also exist in outStatistics",{having:t});return!0}function Z(n,e){return n?Le.get(n,e):null}function We(n){return/\((.*?)\)/.test(n)?n:n.split(Ue)[0]}function ui(n){return n.split(Ue)[1]}function B(n,e,t,i={}){const s=new Map;if(ci(s,n,e,i.allowedFieldTypes??ni,t),s.size){const a=i.expressionName??"expression";throw new v(te,`${a} contains invalid or missing fields`,{errors:Array.from(s.values()),query:i.query})}}function ci(n,e,t,i,s){const a=s.includes("*")?[...t,...s.filter(r=>r!=="*")]:s;for(const r of a)if(e.get(r))Ce(n,e,t,i,r);else try{const l=Ie(e,We(r),{validateStandardized:!0});for(const o of l)Ce(n,e,t,i,o)}catch(l){n.set(r,{type:"expression-error",expression:r,error:l})}}function Ce(n,e,t,i,s){const a=e.get(s);a?t.has(a.name)?i!=="all"&&i?.has(a.type)===!1&&n.set(s,{type:"invalid-type",fieldName:a.name,fieldType:be.fromJSON(a.type),allowedFieldTypes:Array.from(i,r=>be.fromJSON(r))}):n.set(s,{type:"missing-field",fieldName:a.name}):n.set(s,{type:"invalid-field",fieldName:s})}const di=5;let hi=class{constructor(){this._storage=new Map,this._purgeInterval=di,this._sweep=()=>{if(this._timer=void 0,!this._storage)return;const e=1e3*this._purgeInterval,t=performance.now()-e;for(const[i,s]of this._storage){if(!(s.time<t))return void(this._storage.size>0&&(this._timer=setTimeout(this._sweep,e)));this._storage.delete(i)}}}destroy(){this._storage?.clear(),this._storage=null,clearTimeout(this._timer)}put(e,t){this._storage?.set(e,new mi(t)),this._scheduleSweep()}get(e){const t=this._storage?.get(e);if(t)return this._storage?.delete(e),t.time=performance.now(),this._storage?.set(e,t),t.items}clear(){this._storage?.clear()}_scheduleSweep(){this._storage&&(this._timer??=setTimeout(this._sweep,1e3*this._purgeInterval))}get test(){}},fi=0,mi=class{constructor(e){this.items=e,this.time=performance.now(),this.id=fi++}},J=class{constructor(e,t,i){this._fieldDataCache=new Map,this._returnDistinctMap=new Map,this.returnDistinctValues=e.returnDistinctValues??!1,this.fieldsIndex=i,this.featureAdapter=t;const s=e.outFields;if(s&&!s.includes("*")){this.outFields=s;let a=0;for(const r of s){const l=We(r),o=this.fieldsIndex.get(l),u=o?null:Z(l,i),c=o?o.name:ui(r)||"FIELD_EXP_"+a++;this._fieldDataCache.set(r,{alias:c,clause:u})}}}countDistinctValues(e){return this.returnDistinctValues?(e.forEach(t=>this.getAttributes(t)),this._returnDistinctMap.size):e.length}getAttributes(e){const t=this._processAttributesForOutFields(e);return this._processAttributesForDistinctValues(t)}getFieldValue(e,t,i){const s=i?i.name:t;let a=null;return this._fieldDataCache.has(s)?a=this._fieldDataCache.get(s)?.clause:i||(a=Z(t,this.fieldsIndex),this._fieldDataCache.set(s,{alias:s,clause:a})),i?this.featureAdapter.getAttribute(e,s):a?.calculateValue(e,this.featureAdapter)}getDataValues(e,t,i=!0){const s=t.normalizationType,a=t.normalizationTotal,r=this.fieldsIndex.get(t.field),l=pe(r)||ge(r),o=W(r);return e.map(u=>{let c=t.field&&this.getFieldValue(u,t.field,this.fieldsIndex.get(t.field));if(t.field2?(c=`${ue(c)}${t.fieldDelimiter}${ue(this.getFieldValue(u,t.field2,this.fieldsIndex.get(t.field2)))}`,t.field3&&(c=`${c}${t.fieldDelimiter}${ue(this.getFieldValue(u,t.field3,this.fieldsIndex.get(t.field3)))}`)):typeof c=="string"&&i&&(l?c=c?new Date(c).getTime():null:o&&(c=c?kt(c):null)),s&&Number.isFinite(c)){const d=s==="field"&&t.normalizationField?this.getFieldValue(u,t.normalizationField,this.fieldsIndex.get(t.normalizationField)):null;c=Ht(c,s,d,a)}return c})}async getExpressionValues(e,t,i,s,a){const{arcadeUtils:r}=await ke(),l=r.hasGeometryOperations(t);l&&await r.enableGeometryOperations();const o=r.createFunction(t),u=r.getViewInfo(i),c={fields:this.fieldsIndex.fields};return e.map(d=>{const h={attributes:this.featureAdapter.getAttributes(d),layer:c,geometry:l?{...Q(s.geometryType,s.hasZ,s.hasM,this.featureAdapter.getGeometry(d)),spatialReference:i?.spatialReference}:null},m=r.createExecContext(h,u,a);return r.executeFunction(o,m)})}validateItem(e,t){return this._fieldDataCache.has(t)||this._fieldDataCache.set(t,{alias:t,clause:Z(t,this.fieldsIndex)}),this._fieldDataCache.get(t)?.clause?.testFeature(e,this.featureAdapter)??!1}validateItems(e,t){return this._fieldDataCache.has(t)||this._fieldDataCache.set(t,{alias:t,clause:Z(t,this.fieldsIndex)}),this._fieldDataCache.get(t)?.clause?.testSet(e,this.featureAdapter)??!1}_processAttributesForOutFields(e){const t=this.outFields;if(!t?.length)return this.featureAdapter.getAttributes(e);const i={};for(const s of t){const{alias:a,clause:r}=this._fieldDataCache.get(s);i[a]=r?r.calculateValue(e,this.featureAdapter):this.featureAdapter.getAttribute(e,a)}return i}_processAttributesForDistinctValues(e){if(e==null||!this.returnDistinctValues)return e;const t=this.outFields,i=[];if(t)for(const r of t){const{alias:l}=this._fieldDataCache.get(r);i.push(e[l])}else for(const r in e)i.push(e[r]);const s=`${(t||["*"]).join(",")}=${i.join(",")}`;let a=this._returnDistinctMap.get(s)||0;return this._returnDistinctMap.set(s,++a),a>1?null:e}};const H="bin";class A{constructor(e,t,i){this.items=e,this.query=t,this.geometryType=i.geometryType,this.hasM=i.hasM,this.hasZ=i.hasZ,this.fieldsIndex=i.fieldsIndex,this.objectIdField=i.objectIdField,this.spatialReference=i.spatialReference,this.featureAdapter=i.featureAdapter}get size(){return this.items.length}createQueryResponseForCount(){const e=new J(this.query,this.featureAdapter,this.fieldsIndex);if(!this.query.outStatistics)return e.countDistinctValues(this.items);const{groupByFieldsForStatistics:t,having:i,outStatistics:s}=this.query;if(!t?.length)return 1;const r=new Map,l=new Map,o=new Set;for(const u of s){const{statisticType:c}=u,d=c!=="exceedslimit"?u.onStatisticField:void 0;if(!l.has(d)){const m=[];for(const f of t){const y=this._getAttributeValues(e,f,this.items,r);m.push(y)}l.set(d,this._calculateUniqueValues(m,this.items,e.returnDistinctValues))}const h=l.get(d);for(const m in h){const{data:f,items:y}=h[m],x=f.join(",");i&&!e.validateItems(y,i)||o.add(x)}}return o.size}async createQueryResponse(){let e;if(this.query.outStatistics?e=this.query.outStatistics.some(t=>t.statisticType==="exceedslimit")?this._createExceedsLimitQueryResponse():await this._createStatisticsQueryResponse(this.query,this.items):e=this._createFeatureQueryResponse(this.query),this.query.returnQueryGeometry){const t=this.query.geometry;L(this.query.outSR)&&!G(t.spatialReference,this.query.outSR)?e.queryGeometry=ee({spatialReference:this.query.outSR,...C(t,t.spatialReference,this.query.outSR)}):e.queryGeometry=ee({spatialReference:this.query.outSR,...t})}return e}createSnappingResponse(e,t,i){const s=this.featureAdapter,a=Ze(this.hasZ,this.hasM),{point:r,mode:l}=e,o=typeof e.distance=="number"?e.distance:e.distance.x,u=typeof e.distance=="number"?e.distance:e.distance.y,c={candidates:[]},d=this.geometryType==="esriGeometryPolygon",h=this.geometryType==="esriGeometryPolyline"||this.geometryType==="esriGeometryPoint",m=this._getPointCreator(l,t,this.spatialReference,i),f=new je(null,0),y=new je(null,0),x={x:0,y:0,z:0};for(const I of this.items){const w=s.getGeometry(I);if(w==null)continue;const{coords:S}=w,_=w.isPoint?pi:w.lengths;if(f.coords=S,y.coords=S,e.returnEdge){let g=0;for(let F=0;F<_.length;F++){const p=_[F],T=g;for(let R=0;R<p;R++,g+=a){if(!d&&R===p-1)continue;const $=f;$.coordsIndex=g;const b=y;b.coordsIndex=R===p-1?T:g+a;const z=x;if(!yi(x,r,$,b))continue;const E=(r.x-z.x)/o,M=(r.y-z.y)/u,N=E*E+M*M;N<=1&&c.candidates.push(si(s.getObjectId(I),m(z),Math.sqrt(N),m($),m(b)))}}}if(e.vertexMode==="all"){let g=0;for(let F=0;F<_.length;F++){const p=_[F],T=g,R=y;R.coordsIndex=T;for(let $=0;$<p;$++,g+=a){const b=f;if(b.coordsIndex=g,d&&$===p-1&&b.x===R.x&&b.y===R.y)continue;const z=(r.x-b.x)/o,E=(r.y-b.y)/u,M=z*z+E*E;M<=1&&c.candidates.push(qe(s.getObjectId(I),m(b),Math.sqrt(M)))}}}else if(h&&e.vertexMode==="ends"){let g=0;const F=[];for(let p=0;p<_.length;p++){F.push(g);const T=_[p];g+=T*a,!d&&T>1&&F.push(g-a)}for(const p of F){const T=f;T.coordsIndex=p;const R=(r.x-T.x)/o,$=(r.y-T.y)/u,b=R*R+$*$;b<=1&&c.candidates.push(qe(s.getObjectId(I),m(T),Math.sqrt(b)))}}}return c.candidates.sort((I,w)=>I.distance-w.distance),c}_getPointCreator(e,t,i,s){const a=s==null||G(i,s)?o=>o:o=>C(o,i,s),{hasZ:r}=this,l=0;return e==="3d"?r&&t?({x:o,y:u,z:c})=>a({x:o,y:u,z:c}):({x:o,y:u})=>a({x:o,y:u,z:l}):({x:o,y:u})=>a({x:o,y:u})}async createSummaryStatisticsResponse(e){const{field:t,valueExpression:i,normalizationField:s,normalizationType:a,normalizationTotal:r,minValue:l,maxValue:o,scale:u,timeZone:c,outStatisticTypes:d}=e,h=this.fieldsIndex.get(t),m=Ae(h)||pe(h)||ge(h),f=await this._getDataValues({field:t,valueExpression:i,normalizationField:s,normalizationType:a,normalizationTotal:r,scale:u,timeZone:c},this.items),y=Lt({normalizationType:a,normalizationField:s,minValue:l,maxValue:o}),x={value:.5,fieldType:h?.type},I=le(h)?De({values:f,supportsNullCount:y,percentileParams:x,outStatisticTypes:d}):Be({values:f,minValue:l,maxValue:o,useSampleStdDev:!a,supportsNullCount:y,percentileParams:x,outStatisticTypes:d});return Ut(I,d,m)}async createUniqueValuesResponse(e){const{field:t,valueExpression:i,domains:s,returnAllCodedValues:a,scale:r,timeZone:l}=e,o=await this._getDataValues({field:t,field2:e.field2,field3:e.field3,fieldDelimiter:e.fieldDelimiter,valueExpression:i,scale:r,timeZone:l},this.items,!1),u=Jt(o);return Yt(u,s,a,e.fieldDelimiter)}async createClassBreaksResponse(e){const{field:t,valueExpression:i,normalizationField:s,normalizationType:a,normalizationTotal:r,classificationMethod:l,standardDeviationInterval:o,minValue:u,maxValue:c,numClasses:d,scale:h,timeZone:m}=e,f=await this._getDataValues({field:t,valueExpression:i,normalizationField:s,normalizationType:a,normalizationTotal:r,scale:h,timeZone:m},this.items),y=Wt(f,{field:t,normalizationField:s,normalizationType:a,normalizationTotal:r,classificationMethod:l,standardDeviationInterval:o,minValue:u,maxValue:c,numClasses:d});return Xt(y,l)}async createHistogramResponse(e){const{field:t,valueExpression:i,normalizationField:s,normalizationType:a,normalizationTotal:r,classificationMethod:l,standardDeviationInterval:o,minValue:u,maxValue:c,numBins:d,scale:h,timeZone:m}=e,f=await this._getDataValues({field:t,valueExpression:i,normalizationField:s,normalizationType:a,normalizationTotal:r,scale:h,timeZone:m},this.items);return Kt(f,{field:t,normalizationField:s,normalizationType:a,normalizationTotal:r,classificationMethod:l,standardDeviationInterval:o,minValue:u,maxValue:c,numBins:d})}_sortFeatures(e,t,i){if(e.length>1&&t?.length)for(const s of t.slice().reverse()){const a=s.split(" "),r=a[0],l=this.fieldsIndex.get(r),o=!!a[1]&&a[1].toLowerCase()==="desc",u=ei(l?.type,o);e.sort((c,d)=>{const h=i(c,r,l),m=i(d,r,l);return u(h,m)})}}_createFeatureQueryResponse(e){const{items:t,geometryType:i,hasM:s,hasZ:a,objectIdField:r,spatialReference:l}=this,{outFields:o,outSR:u,quantizationParameters:c,resultRecordCount:d,resultOffset:h,returnZ:m,returnM:f}=e,y=d!=null&&t.length>(h||0)+d,x=o&&(o.includes("*")?[...this.fieldsIndex.fields]:o.map(I=>this.fieldsIndex.get(I)));return{exceededTransferLimit:y,features:this._createFeatures(e,t),fields:x,geometryType:i,hasM:s&&f,hasZ:a&&m,objectIdFieldName:r,spatialReference:ee(u||l),transform:c&&$e(c)||null}}_createFeatures(e,t){const i=new J(e,this.featureAdapter,this.fieldsIndex),{hasM:s,hasZ:a}=this,{orderByFields:r,quantizationParameters:l,returnGeometry:o,returnCentroid:u,maxAllowableOffset:c,resultOffset:d,resultRecordCount:h,returnZ:m=!1,returnM:f=!1}=e,y=a&&m,x=s&&f;let I=[],w=0;const S=[...t];if(this._sortFeatures(S,r,(g,F,p)=>i.getFieldValue(g,F,p)),this.geometryType&&(o||u)){const g=$e(l)??void 0,F=this.geometryType==="esriGeometryPolygon"||this.geometryType==="esriGeometryPolyline";if(o&&!u)for(const p of S){const T=this.featureAdapter.getGeometry(p),R=this._addFeatureJSONMetadata(p,{attributes:i.getAttributes(p),geometry:Q(this.geometryType,this.hasZ,this.hasM,T,c,g,y,x)});F&&T&&!R.geometry&&(R.centroid=de(this,this.featureAdapter.getCentroid(p,this),g)),I[w++]=R}else if(!o&&u)for(const p of S)I[w++]=this._addFeatureJSONMetadata(p,{attributes:i.getAttributes(p),centroid:de(this,this.featureAdapter.getCentroid(p,this),g)});else for(const p of S)I[w++]=this._addFeatureJSONMetadata(p,{attributes:i.getAttributes(p),centroid:de(this,this.featureAdapter.getCentroid(p,this),g),geometry:Q(this.geometryType,this.hasZ,this.hasM,this.featureAdapter.getGeometry(p),c,g,y,x)})}else for(const g of S){const F=i.getAttributes(g);F&&(I[w++]=this._addFeatureJSONMetadata(g,{attributes:F}))}const _=d||0;if(h!=null){const g=_+h;I=I.slice(_,Math.min(I.length,g))}return I}_addFeatureJSONMetadata(e,t){const i=this.featureAdapter.getMetadata?.(e);return i!==void 0&&(t.metadata=i),t}_createExceedsLimitQueryResponse(){let e=!1,t=Number.POSITIVE_INFINITY,i=Number.POSITIVE_INFINITY,s=Number.POSITIVE_INFINITY;for(const a of this.query.outStatistics??[])if(a.statisticType==="exceedslimit"){t=a.maxPointCount!=null?a.maxPointCount:Number.POSITIVE_INFINITY,i=a.maxRecordCount!=null?a.maxRecordCount:Number.POSITIVE_INFINITY,s=a.maxVertexCount!=null?a.maxVertexCount:Number.POSITIVE_INFINITY;break}if(this.geometryType==="esriGeometryPoint")e=this.items.length>t;else if(this.items.length>i)e=!0;else{const a=Ze(this.hasZ,this.hasM),r=this.featureAdapter;e=this.items.reduce((l,o)=>{const u=r.getGeometry(o);return l+(u!=null&&u.coords.length||0)},0)/a>s}return{fields:[{name:"exceedslimit",type:"esriFieldTypeInteger",alias:"exceedslimit",sqlType:"sqlTypeInteger",domain:null,defaultValue:null}],features:[{attributes:{exceedslimit:Number(e)}}]}}async _createStatisticsQueryResponse(e,t,i={attributes:{}}){const s=[],a=new Map,r=new Map,l=new Map,o=new Map,u=new J(e,this.featureAdapter,this.fieldsIndex),c=e.outStatistics,{groupByFieldsForStatistics:d,having:h,orderByFields:m,resultRecordCount:f}=e,y=d?.length,x=!!y,I=x?d[0]:null,w=x&&!this.fieldsIndex.get(I);for(const _ of c??[]){const{outStatisticFieldName:g,statisticType:F}=_,p=_,T=F!=="exceedslimit"?_.onStatisticField:void 0,R=F==="percentile_disc"||F==="percentile_cont",$=F==="EnvelopeAggregate"||F==="CentroidAggregate"||F==="ConvexHullAggregate",b=x&&y===1&&(T===I||w)&&F==="count";if(x){if(!l.has(T)){const N=[];for(const ne of d){const se=this._getAttributeValues(u,ne,t,a);N.push(se)}l.set(T,this._calculateUniqueValues(N,t,!$&&u.returnDistinctValues))}const E=l.get(T);if(!E)continue;const M=Object.keys(E);for(const N of M){const{count:ne,data:se,items:Te,itemPositions:st}=E[N],Re=se.join(",");if(!h||u.validateItems(Te,h)){const k=o.get(Re)||{attributes:{}};if($){k.aggregateGeometries||(k.aggregateGeometries={});const{aggregateGeometries:P,outStatisticFieldName:U}=await this._getAggregateGeometry(p,Te);k.aggregateGeometries[U]=P}else{let P=null;if(b)P=ne;else{const U=this._getAttributeValues(u,T,t,a),ve=st.map(rt=>U[rt]);P=R&&"statisticParameters"in p?this._getPercentileValue(p,ve):this._getStatisticValue(p,ve,null,u.returnDistinctValues)}k.attributes[g]=P}let at=0;d.forEach((P,U)=>k.attributes[this.fieldsIndex.get(P)?P:"EXPR_"+ ++at]=se[U]),o.set(Re,k)}}}else if($){i.aggregateGeometries||(i.aggregateGeometries={});const{aggregateGeometries:E,outStatisticFieldName:M}=await this._getAggregateGeometry(p,t);i.aggregateGeometries[M]=E}else{const E=this._getAttributeValues(u,T,t,a);i.attributes[g]=R&&"statisticParameters"in p?this._getPercentileValue(p,E):this._getStatisticValue(p,E,r,u.returnDistinctValues)}const z=F!=="min"&&F!=="max"||!le(this.fieldsIndex.get(T))&&!this._isAnyDateField(T)?null:this.fieldsIndex.get(T)?.type;s.push({name:g,alias:g,type:z||"esriFieldTypeDouble"})}const S=x?Array.from(o.values()):[i];return this._sortFeatures(S,m,(_,g)=>_.attributes[g]),f&&(S.length=Math.min(f,S.length)),{fields:s,features:S}}_isAnyDateField(e){const t=this.fieldsIndex.get(e);return Ae(t)||pe(t)||ge(t)||W(t)}async _getAggregateGeometry(e,t){const{convexHull:i,union:s}=await D(()=>import("./geometryEngineJSON-B_JiqPb-.js").then(y=>y.g),__vite__mapDeps([0,1,2])),{statisticType:a,outStatisticFieldName:r}=e,{featureAdapter:l,spatialReference:o,geometryType:u,hasZ:c,hasM:d}=this,h=t.map(y=>Q(u,c,d,l.getGeometry(y))),m=i(o,h,!0)[0],f={aggregateGeometries:null,outStatisticFieldName:null};if(a==="EnvelopeAggregate"){const y=m?dt(m):Ee(s(o,h));f.aggregateGeometries={...y,spatialReference:o},f.outStatisticFieldName=r||"extent"}else if(a==="CentroidAggregate"){const y=m?ht(m):ft(Ee(s(o,h)));f.aggregateGeometries={x:y[0],y:y[1],spatialReference:o},f.outStatisticFieldName=r||"centroid"}else a==="ConvexHullAggregate"&&(f.aggregateGeometries=m,f.outStatisticFieldName=r||"convexHull");return f}_getStatisticValue(e,t,i,s){const{onStatisticField:a,statisticType:r}=e;let l=null;return l=i?.has(a)?i.get(a):le(this.fieldsIndex.get(a))||this._isAnyDateField(a)?De({values:t,returnDistinct:s}):Be({values:s?[...new Set(t)]:t,minValue:null,maxValue:null,useSampleStdDev:!0}),i&&i.set(a,l),l[r==="var"?"variance":r]}_getPercentileValue(e,t){const{onStatisticField:i,statisticParameters:s,statisticType:a}=e,{value:r,orderBy:l}=s,o=this.fieldsIndex.get(i);return ti(t,{value:r,orderBy:l,fieldType:o?.type,isDiscrete:a==="percentile_disc"})}_getAttributeValues(e,t,i,s){if(s.has(t))return s.get(t);const a=this.fieldsIndex.get(t),r=i.map(l=>e.getFieldValue(l,t,a));return s.set(t,r),r}_calculateUniqueValues(e,t,i){const s={},a=t.length;for(let r=0;r<a;r++){const l=t[r],o=[];for(const c of e)o.push(c[r]);const u=o.join(",");s[u]==null?s[u]={count:1,data:o,items:[l],itemPositions:[r]}:(i||s[u].count++,s[u].items.push(l),s[u].itemPositions.push(r))}return s}async _getDataValues(e,t,i=!0){const s=new J(this.query,this.featureAdapter,this.fieldsIndex),{valueExpression:a,scale:r,timeZone:l}=e;return a?s.getExpressionValues(t,a,{viewingMode:"map",scale:r,spatialReference:this.query.outSR||this.spatialReference},{geometryType:this.geometryType,hasZ:this.hasZ,hasM:this.hasM},l):s.getDataValues(t,X(e),i)}_calculateHistogramBins(e,t,i){if(t.min==null&&t.max==null)return[];const s=t.intervals,a=t.min??0,r=t.max??0,l=s.map(([o,u])=>({minValue:o,maxValue:u,count:0,items:[]}));for(let o=0;o<e.length;o++){const u=e[o],c=i[o];if(u!=null&&u>=a&&u<=r){const d=ii(s,u);d>-1&&(l[d].count++,l[d].items.push(c))}}return l}async createQueryBinsResponse(e){const t=e.bin?.splitBy;if(!t)return this._createBinsResponse(e);const{value:i,outAlias:s,valueType:a}=t,r=[],l=[{name:s??i,alias:s??i,type:a??"esriFieldTypeString"},{name:H,alias:H,type:"esriFieldTypeInteger"}],o=new J(e,this.featureAdapter,this.fieldsIndex),u=new Map,c=[...this.items];this._sortFeatures(c,[i],(m,f,y)=>o.getFieldValue(m,f,y));const d=this._getAttributeValues(o,i,c,u),h=this._calculateUniqueValues([d],c,o.returnDistinctValues);for(const m in h){const{items:f}=h[m],y=await this._createBinsResponse(e,f);if(r.push(...y.features.map(x=>({...x,attributes:{...x.attributes,[s??i]:m}}))),y.fields)for(const x of y.fields)l.some(I=>I.name===x.name)||l.push(x)}return{fields:l,features:r}}async _createBinsResponse(e,t){const i=e.bin;switch(t=t??this.items,i.type){case"autoIntervalBin":return this._createAutoIntervalBinsResponse(Nt.fromJSON(i),e,t);case"dateBin":return this._createDateBinsResponse(Bt.fromJSON(i),e,t);case"fixedBoundariesBin":return this._createFixedBoundariesBinsResponse(Dt.fromJSON(i),e,t);case"fixedIntervalBin":return this._createFixedIntervalBinsResponse(Pt.fromJSON(i),e,t)}}async _createAutoIntervalBinsResponse(e,t,i){const{field:s,normalizationField:a,numBins:r,normalizationType:l,normalizationTotal:o,start:u,end:c}=e,d=await this._getDataValues({field:e.field,normalizationField:e.normalizationField,normalizationType:e.normalizationType,normalizationTotal:e.normalizationTotal,timeZone:t.outTimeReference?.ianaTimeZone},i),h=Ne(d,{field:s,normalizationField:a,normalizationType:l,normalizationTotal:o,numBins:r,minValue:q(u,!1),maxValue:q(c,!1)}),m=this._calculateHistogramBins(d,h,i);return this._createFeaturesFromHistogramBins(m,t)}async _createDateBinsResponse(e,t,i){const{field:s,interval:a,start:r,end:l,snapToData:o,returnFullIntervalBin:u}=e,c=a.unit,d=await this._getDataValues({field:e.field,timeZone:t.outTimeReference?.ianaTimeZone},i),h=W(this.fieldsIndex.get(s)),m=qt.toJSON(c),f=d.filter(Boolean).sort((S,_)=>S-_),y=r!=null?q(r,h):f[0],x=l!=null?q(l,h):f[f.length-1],I=[];if(y!=null&&x!=null){const S={zone:t.outTimeReference?.ianaTimeZone??mt},_=ae.fromMillis(y,S),g=ae.fromMillis(x,S);if(o==="last"){let F=g;for(;F>_;){const p=F.minus({[m]:a.value});if(p<_){I.unshift([u?p.toMillis():_.toMillis(),F.toMillis()]);break}I.unshift([p.toMillis(),F.toMillis()]),F=p}}else{let F=o==="first"?_:_.startOf(m);for(;F<=g;){const p=F.plus({[m]:a.value});if(p>g){I.push([F.toMillis(),u?p.toMillis():g.toMillis()]);break}I.push([F.toMillis(),p.toMillis()]),F=p}}}const w=this._calculateHistogramBins(d,{intervals:I,min:y,max:x},i);return this._createFeaturesFromHistogramBins(w,t)}async _createFixedBoundariesBinsResponse(e,t,i){const{field:s}=e,a=await this._getDataValues({field:s,timeZone:t.outTimeReference?.ianaTimeZone},i),r=W(this.fieldsIndex.get(s)),l=e.boundaries.map(d=>q(d,r)).sort((d,h)=>d-h),o=[];for(let d=0;d<l.length-1;d++)o.push([l[d],l[d+1]]);const u={intervals:o,min:l.at(0),max:l.at(-1)},c=this._calculateHistogramBins(a,u,i);return this._createFeaturesFromHistogramBins(c,t)}async _createFixedIntervalBinsResponse(e,t,i){const{field:s,interval:a,start:r,end:l}=e,o=await this._getDataValues({field:e.field,normalizationField:e.normalizationField,normalizationType:e.normalizationType,normalizationTotal:e.normalizationTotal,timeZone:t.outTimeReference?.ianaTimeZone},i),u=W(this.fieldsIndex.get(s)),c=Ne(o,{field:s,classificationMethod:"defined-interval",definedInterval:a,minValue:q(r,u),maxValue:q(l,u)},!0),d=this._calculateHistogramBins(o,c,i);return this._createFeaturesFromHistogramBins(d,t)}async _createFeaturesFromHistogramBins(e,t){const{upperBoundaryAlias:i,lowerBoundaryAlias:s}=t,a=s||"lowerBoundary",r=i||"upperBoundary",l=[],o=[{name:a,alias:a,type:"esriFieldTypeDouble"},{name:r,alias:r,type:"esriFieldTypeDouble"}],u=t.bin?.stackBy?.value,c=t.bin?.stackBy?.outAlias;u&&o.push({name:H,alias:H,type:"esriFieldTypeInteger"},{name:c??u,alias:c??u,type:"esriFieldTypeString"});let d=0;const h=t.bin.type==="dateBin",m=t.outTimeReference?.ianaTimeZone;for(const f of e){const{minValue:y,maxValue:x,items:I}=f,w={attributes:{}};let S;if(w.attributes[a]=h&&m&&y!=null?ae.fromMillis(y,{zone:m}).toISO():y,w.attributes[r]=h&&m&&x!=null?ae.fromMillis(x,{zone:m}).toISO():x,u?(S=await this._createStatisticsQueryResponse({...t,groupByFieldsForStatistics:[u],orderByFields:[u]},I),w.attributes[H]=++d,t.bin.jsonStyle==="flat"?l.push(...S.features.map(({attributes:{EXPR_1:_,...g},...F})=>({...F,attributes:c??_?{...g,[c??_]:_,...w.attributes}:{...g,...w.attributes}}))):(w.stackedAttributes=S.features.map(({attributes:{EXPR_1:_,...g}})=>c??_?{...g,[c??_]:_}:g),l.push(w))):(t.bin?.splitBy&&(w.attributes[H]=++d),S=await this._createStatisticsQueryResponse(t,I,w),l.push(w)),S.fields)for(const _ of S.fields)o.some(g=>g.name===_.name)||o.push(_)}return t.binOrder==="desc"&&l.reverse(),{fields:o,features:l}}}function yi(n,e,t,i){const s=i.x-t.x,a=i.y-t.y,r=e.x-t.x,l=e.y-t.y,o=s*s+a*a;if(o===0)return!1;const u=r*s+l*a,c=Math.min(1,Math.max(0,u/o));return n.x=t.x+s*c,n.y=t.y+a*c,!0}function Ze(n,e){return n?e?4:3:e?3:2}class je{constructor(e,t){this.coords=e,this.coordsIndex=t}get x(){return this.coords[this.coordsIndex]}get y(){return this.coords[this.coordsIndex+1]}get z(){return this.coords[this.coordsIndex+2]}}const pi=[1];function gi(n){return n==="mesh"?yt:pt(n)}function Xe(n,e){return n?e?4:3:e?3:2}function xi(n,e,t,i){return Ke(n,e,t,i.coords[0],i.coords[1])}function _i(n,e,t,i,s,a){const r=Xe(s,a),{coords:l,lengths:o}=i;if(!o)return!1;for(let u=0,c=0;u<o.length;u++,c+=r)if(!Ke(n,e,t,l[c],l[c+1]))return!1;return!0}function Ke(n,e,t,i,s){if(!n)return!1;const a=Xe(e,t),{coords:r,lengths:l}=n;let o=!1,u=0;for(const c of l)o=Fi(o,r,a,u,c,i,s),u+=c*a;return o}function Fi(n,e,t,i,s,a,r){let l=n,o=i;for(let u=i,c=i+s*t;u<c;u+=t){o=u+t,o===c&&(o=i);const d=e[u],h=e[u+1],m=e[o],f=e[o+1];(h<r&&f>=r||f<r&&h>=r)&&d+(r-h)/(f-h)*(m-d)<a&&(l=!l)}return l}const he="unsupported-query",we={spatialRelationship:{esriSpatialRelIntersects:!0,esriSpatialRelContains:!0,esriSpatialRelWithin:!0,esriSpatialRelCrosses:!0,esriSpatialRelDisjoint:!0,esriSpatialRelTouches:!0,esriSpatialRelOverlaps:!0,esriSpatialRelEnvelopeIntersects:!0,esriSpatialRelIndexIntersects:!1,esriSpatialRelRelation:!1},queryGeometry:{esriGeometryPoint:!0,esriGeometryMultiPatch:!1,esriGeometryMultipoint:!0,esriGeometryPolyline:!0,esriGeometryPolygon:!0,esriGeometryEnvelope:!0},layerGeometry:{esriGeometryPoint:!0,esriGeometryMultiPatch:!0,esriGeometryMultipoint:!0,esriGeometryPolyline:!0,esriGeometryPolygon:!0,esriGeometryEnvelope:!1}};function Si(n){return n!=null&&we.spatialRelationship[n]===!0}function Ii(n){return n!=null&&we.queryGeometry[_t(n)]===!0}function wi(n){return n!=null&&we.layerGeometry[n]===!0}const Ti={esriSpatialRelIntersects:()=>D(()=>import("./intersectsOperator-BXc1n3Vv.js"),__vite__mapDeps([3,4,5,6,7,8,9,10,11,12,13])),esriSpatialRelContains:()=>D(()=>import("./containsOperator-BIK4PhY4.js"),__vite__mapDeps([14,5,6,7,8,9,10,11,12,13])),esriSpatialRelCrosses:()=>D(()=>import("./crossesOperator-Bvq7usl4.js"),__vite__mapDeps([15,16,5,6,7,8,9,10,11,12,13])),esriSpatialRelDisjoint:()=>D(()=>import("./disjointOperator-BRtutiqd.js"),__vite__mapDeps([17,5,6,7,8,9,10,11,12,13])),esriSpatialRelEnvelopeIntersects:null,esriSpatialRelIndexIntersects:null,esriSpatialRelOverlaps:()=>D(()=>import("./overlapsOperator-BTVgS_LM.js"),__vite__mapDeps([18,19,5,6,7,8,9,10,11,12,13])),esriSpatialRelTouches:()=>D(()=>import("./touchesOperator-B557H-V1.js"),__vite__mapDeps([20,21,5,6,7,8,9,10,11,12,13])),esriSpatialRelWithin:()=>D(()=>import("./withinOperator-843dE_mc.js"),__vite__mapDeps([22,23,5,6,7,8,9,10,11,12,13])),esriSpatialRelRelation:null};function Ri(n){const e=Ti[n];if(e==null)throw new Error(`Cannot load unsupported spatial operator: ${n}`);return e()}async function Y(n,e,t,i,s){if(Fe(e)){if(t==="esriGeometryPoint"&&(n==="esriSpatialRelIntersects"||n==="esriSpatialRelContains")){const r=Ve(new ie,e,!1,!1);return l=>xi(r,!1,!1,l)}if(t==="esriGeometryMultipoint"){const r=Ve(new ie,e,!1,!1);if(n==="esriSpatialRelContains")return l=>_i(r,!1,!1,l,i,s)}}if(Se(e)){if(t==="esriGeometryPoint"&&(n==="esriSpatialRelIntersects"||n==="esriSpatialRelContains"))return r=>gt(e,Q(t,i,s,r));if(t==="esriGeometryMultipoint"&&n==="esriSpatialRelContains")return r=>xt(e,Q(t,i,s,r));if(n==="esriSpatialRelIntersects"){const r=gi(t);return l=>r(e,Q(t,i,s,l))}}n==="esriSpatialRelEnvelopeIntersects"&&(n="esriSpatialRelIntersects");const a=await Ri(n);return r=>a.execute(e,Q(t,i,s,r))}async function et(n,e,t){const{spatialRel:i,geometry:s}=n;if(s){if(!Si(i))throw new v(he,"Unsupported query spatial relationship",{query:n});if(L(s.spatialReference)&&L(t)){if(!Ii(s))throw new v(he,"Unsupported query geometry type",{query:n});if(!wi(e))throw new v(he,"Unsupported layer geometry type",{query:n});if(n.outSR)return re(n.geometry?.spatialReference,n.outSR)}}}function tt(n){if(Se(n))return!0;if(Fe(n)){for(const e of n.rings)if(e.length!==5||e[0][0]!==e[1][0]||e[0][0]!==e[4][0]||e[2][0]!==e[3][0]||e[0][1]!==e[3][1]||e[0][1]!==e[4][1]||e[1][1]!==e[2][1])return!1;return!0}return!1}const j="unsupported-query";async function vi(n,e){const t=n.bin;if(!t.onField&&!t.onExpression?.value||t.type==="autoIntervalBin"&&t.parameters.numberOfBins==null||t.type==="dateBin"&&(t.parameters.number==null||t.parameters.unit==null)||t.type==="fixedBoundariesBin"&&t.parameters.boundaries==null||t.type==="fixedIntervalBin"&&t.parameters.interval==null)throw new v(j,"Unsupported query options",{query:n});return _e(n,e)}async function _e(n,{fieldsIndex:e,geometryType:t,spatialReference:i,availableFields:s}){if(n.geometryPrecision!=null||n.multipatchOption&&n.multipatchOption!=="xyFootprint"||n.pixelSize||n.relationParam||n.text)throw new v(j,"Unsupported query options",{query:n});return it(e,s,n),Ai(e,s,n),Promise.all([et(n,t,i),re(i,n.outSR)]).then(()=>n)}function it(n,e,t){const{returnDistinctValues:i,outStatistics:s}=t,a=s?s.map(r=>r.outStatisticFieldName&&r.outStatisticFieldName.toLowerCase()).filter(Boolean):[];if("orderByFields"in t&&t.orderByFields&&t.orderByFields.length>0){const r=" asc",l=" desc",o=t.orderByFields.map(u=>{const c=u.toLowerCase();return c.includes(r)?c.split(r)[0]:c.includes(l)?c.split(l)[0]:u}).filter(u=>!a.includes(u));B(n,e,o,{expressionName:"orderByFields",query:t})}if("outFields"in t){if(t.outFields?.length)B(n,e,t.outFields,{expressionName:"outFields",query:t,allowedFieldTypes:"all"});else if(i)throw new v(j,"outFields should be specified for returnDistinctValues",{query:t})}li(n,e,t.where,t)}const bi=new Set([...Je,...Ye]);function Ai(n,e,t){const{outStatistics:i,groupByFieldsForStatistics:s,having:a}=t,r=s?.length,l=i?.length;if(a){if(!r||!l)throw new v(j,"outStatistics and groupByFieldsForStatistics should be specified with having",{query:t});oi(n,e,a,i,t)}if(l){if(!Vi(i))return;const o=i.map(u=>u.onStatisticField).filter(Boolean);B(n,e,o,{expressionName:"onStatisticFields",query:t}),r&&B(n,e,s,{expressionName:"groupByFieldsForStatistics",query:t});for(const u of i){const{onStatisticField:c,statisticType:d}=u;if((d==="percentile_disc"||d==="percentile_cont")&&"statisticParameters"in u){const{statisticParameters:h}=u;if(!h)throw new v(j,"statisticParameters should be set for percentile type",{definition:u,query:t})}else n.get(c)&&d!=="count"&&d!=="min"&&d!=="max"&&B(n,e,[c],{expressionName:`outStatistics with '${d}' statistic type`,allowedFieldTypes:bi,query:t})}}}async function $i(n,e,{fieldsIndex:t,geometryType:i,spatialReference:s,availableFields:a}){if(n.geometryPrecision!=null||n.multipatchOption||n.pixelSize||n.relationParam||n.text||n.outStatistics||n.groupByFieldsForStatistics||n.having||n.orderByFields)throw new v(j,"Unsupported query options",{query:n});return it(t,a,n),Promise.all([Ei(t,a,e,n),et(n,i,s),re(s,n.outSR)]).then(()=>n)}async function Ei(n,e,t,i){let s=[];if(t.valueExpression){const{arcadeUtils:a}=await ke();s=a.extractFieldNames(t.valueExpression)}if(t.field&&s.push(t.field),t.field2&&s.push(t.field2),t.field3&&s.push(t.field3),t.normalizationField&&s.push(t.normalizationField),!s.length&&!t.valueExpression)throw new v(j,"field or valueExpression is required",{params:t});B(n,e,s,{expressionName:"statistics",query:i})}function Vi(n){return n!=null&&n.every(e=>e.statisticType!=="exceedslimit")}async function Mi(n,e){if(!n)return null;const t=e.featureAdapter,{startTimeField:i,endTimeField:s}=n;let a=Number.POSITIVE_INFINITY,r=Number.NEGATIVE_INFINITY;if(i&&s)await e.forEach(l=>{const o=t.getAttribute(K(l),i),u=t.getAttribute(K(l),s);o==null||isNaN(o)||(a=Math.min(a,o)),u==null||isNaN(u)||(r=Math.max(r,u))});else{const l=i||s;await e.forEach(o=>{const u=t.getAttribute(K(o),l);u==null||isNaN(u)||(a=Math.min(a,u),r=Math.max(r,u))})}return{start:a,end:r}}function Gi(n,e,t){if(!e||!n)return null;const{startTimeField:i,endTimeField:s}=n;if(!i&&!s)return null;const{start:a,end:r}=e;if(a===null&&r===null)return null;if(a===void 0&&r===void 0)return Pi();const l=t.getAttributeAsTimestamp?.bind(t)??t.getAttribute.bind(t);return i&&s?Qi(l,i,s,a,r):zi(l,i||s,a,r)}function Qi(n,e,t,i,s){return i!=null&&s!=null?a=>{const r=n(a,e),l=n(a,t);return(r==null||r<=s)&&(l==null||l>=i)}:i!=null?a=>{const r=n(a,t);return r==null||r>=i}:s!=null?a=>{const r=n(a,e);return r==null||r<=s}:void 0}function zi(n,e,t,i){return t!=null&&i!=null&&t===i?s=>n(s,e)===t:t!=null&&i!=null?s=>{const a=n(s,e);return a!=null&&a>=t&&a<=i}:t!=null?s=>{const a=n(s,e);return a!=null&&a>=t}:i!=null?s=>{const a=n(s,e);return a!=null&&a<=i}:void 0}function Pi(){return()=>!1}const Di="unsupported-query";class Ji{constructor(e){this._changeHandle=null,this.capabilities={query:jt},this.geometryType=e.geometryType,this.hasM=!!e.hasM,this.hasZ=!!e.hasZ,this.spatialReference=e.spatialReference,this.definitionExpression=e.definitionExpression,this.featureStore=e.featureStore,this.aggregateAdapter=e.aggregateAdapter,this._cache=e.cache??new hi,this.timeInfo=e.timeInfo,this.featureIdInfo=e.featureIdInfo,e.featureIdInfo.type==="object-id"&&(this.objectIdField=e.featureIdInfo.fieldName),this._changeHandle=this.featureStore.events.on("changed",()=>this._clearCache()),this.fieldsIndex=Ft(e.fieldsIndex)?e.fieldsIndex:St.fromJSON(e.fieldsIndex),!e.availableFields||e.availableFields.length===1&&e.availableFields[0]==="*"?this.availableFields=new Set(this.fieldsIndex.fields.map(t=>t.name)):this.availableFields=new Set(e.availableFields.map(t=>this.fieldsIndex.get(t)?.name).filter(t=>t!=null)),e.scheduler&&e.priority?this._frameTask=e.scheduler.registerTask(e.priority):this._frameTask=It}destroy(){this._changeHandle=Me(this._changeHandle),this._frameTask=Me(this._frameTask),this._clearCache(),wt(this._cache)}get featureAdapter(){return this.featureStore.featureAdapter}async executeQuery(e,t){const i=V(t);return await this._frameTask.scheduleGenerator(()=>this._executeQueryFeatureSet(e),i)}async executeQueryForCount(e={},t){const i=V(t);return await this._frameTask.scheduleGenerator(()=>this._executeQueryForCount(e),i)}async executeQueryForExtent(e,t){const i=V(t);return await this._frameTask.scheduleGenerator(()=>this._executeQueryForExtent(e),i)}async executeQueryForIds(e,t){return Array.from(await this.executeQueryForIdSet(e,t))}async executeQueryForIdSet(e,t){const i=V(t);return await this._frameTask.scheduleGenerator(()=>this._executeQueryForIdSet(e),i)}async executeQueryForLatestObservations(e,t){const i=V(t);if(!this.timeInfo?.trackIdField)throw new v(Di,"Missing timeInfo or timeInfo.trackIdField",{query:e,timeInfo:this.timeInfo});return await this._frameTask.scheduleGenerator(()=>this._executeQueryForLatestObservations(e),i)}async executeQueryForOpaqueFeatures(e,t){const i=V(t);return(await this._frameTask.scheduleGenerator(()=>this._executeQuery(e,{}),i)).items}async executeAttributeBinsQuery(e,t){const i=V(t);return e=X(e),await this._frameTask.scheduleGenerator(()=>this._executeAttributeBinsQuery(e),i)}async executeQueryForSummaryStatistics(e={},t,i){const s=V(i);return await this._frameTask.scheduleGenerator(()=>this._executeQueryForSummaryStatistics(e,t),s)}async executeQueryForUniqueValues(e={},t,i){const s=V(i);return await this._frameTask.scheduleGenerator(()=>this._executeQueryForUniqueValues(e,t),s)}async executeQueryForClassBreaks(e={},t,i){const s=V(i);return await this._frameTask.scheduleGenerator(()=>this._executeQueryForClassBreaks(e,t),s)}async executeQueryForHistogram(e={},t,i){const s=V(i);return await this._frameTask.scheduleGenerator(()=>this._executeQueryForHistogram(e,t),s)}async executeQueryForSnapping(e,t){const i=V(t);return await this._frameTask.scheduleGenerator(()=>this._executeQueryForSnapping(e,i),i)}async fetchRecomputedExtents(e){const t=V(e);this._timeExtentPromise||=Mi(this.timeInfo,this.featureStore);const[i,s]=await Promise.all([this._getFullExtent(),this._timeExtentPromise]);return Tt(t),{fullExtent:i,timeExtent:s}}_clearCache(){this._cache.clear(),this._allFeaturesPromise=null,this._timeExtentPromise=null,this._fullExtentPromise=null}async*_executeQueryFeatureSet(e){try{const t=yield*this._executeQuery(e,{});return yield,await t.createQueryResponse()}catch(t){if(t!==O)throw t;return await new A([],e,this).createQueryResponse()}}async*_executeQueryForCount(e){try{const t=yield*this._executeQuery(e,{returnGeometry:!1,returnCentroid:!1,outSR:null});return yield,t.createQueryResponseForCount()}catch(t){if(t!==O)throw t;return 0}}async*_executeQueryForExtent(e){const t=e.outSR;try{const i=yield*this._executeQuery(e,{returnGeometry:!0,returnCentroid:!1,outSR:null});yield;const s=i.size;if(!s)return{count:0,extent:null};const a=await this._getBounds(i.items,i.spatialReference,t??this.spatialReference);return yield,{count:s,extent:a}}catch(i){if(i===O)return{count:0,extent:null};throw i}}async*_executeQueryForIdSet(e){try{const t=yield*this._executeQuery(e,{returnGeometry:!0,returnCentroid:!1,outSR:null});yield;const i=t.items,s=new Set;for(const a of i)s.add(t.featureAdapter.getObjectId(a));return s}catch(t){if(t===O)return new Set;throw t}}async*_executeQueryForLatestObservations(e){try{const t=yield*this._executeQuery(e,{});return yield,this._filterLatest(t),yield,await t.createQueryResponse()}catch(t){if(t!==O)throw t;return await new A([],e,this).createQueryResponse()}}async*_executeAttributeBinsQuery(e){let t;try{e=await Ot(e,this.definitionExpression,this.spatialReference),yield,e=await vi(e,{availableFields:this.availableFields,fieldsIndex:this.fieldsIndex,geometryType:this.geometryType,spatialReference:this.spatialReference}),yield;const i=yield*this._executeSceneFilterQuery(e);yield,t=yield*this._executeGeometryQuery(e,i),yield,this._executeAggregateIdsQuery(t),yield,this._executeObjectIdsQuery(t),yield,this._executeTimeQuery(t),yield,this._executeAttributesQuery(t),yield}catch(i){if(i!==O)throw i;t=new A([],e,this)}return await t.createQueryBinsResponse(e)}async*_executeQueryForSummaryStatistics(e={},t){const{field:i,normalizationField:s,valueExpression:a}=t,r=yield*this._executeQueryForStatistics(e,{field:i,normalizationField:s,valueExpression:a});return yield,await r.createSummaryStatisticsResponse(t)}async*_executeQueryForUniqueValues(e={},t){const{field:i,field2:s,field3:a,valueExpression:r}=t,l=yield*this._executeQueryForStatistics(e,{field:i,field2:s,field3:a,valueExpression:r});return yield,await l.createUniqueValuesResponse(t)}async*_executeQueryForClassBreaks(e,t){const{field:i,normalizationField:s,valueExpression:a}=t,r=yield*this._executeQueryForStatistics(e,{field:i,normalizationField:s,valueExpression:a});return yield,await r.createClassBreaksResponse(t)}async*_executeQueryForHistogram(e,t){const{field:i,normalizationField:s,valueExpression:a}=t,r=yield*this._executeQueryForStatistics(e,{field:i,normalizationField:s,valueExpression:a});return yield,await r.createHistogramResponse(t)}async*_executeQueryForSnapping(e,t){const{point:i,distance:s,returnEdge:a,vertexMode:r}=e;if(!a&&r==="none")return{candidates:[]};let l=X(e.query);l=await Ct(l,this.definitionExpression,this.spatialReference),yield,l=await _e(l,{availableFields:this.availableFields,fieldsIndex:this.fieldsIndex,geometryType:this.geometryType,spatialReference:this.spatialReference}),yield;const o=!G(i.spatialReference,this.spatialReference);o&&(await re(i.spatialReference,this.spatialReference),yield);const u=typeof s=="number"?s:s.x,c=typeof s=="number"?s:s.y,d={xmin:i.x-u,xmax:i.x+u,ymin:i.y-c,ymax:i.y+c,spatialReference:i.spatialReference},h=o?C(d,this.spatialReference):d;if(!h)return{candidates:[]};const m=(await Ge(Qe(i),null,{signal:t}))[0];yield;const f=(await Ge(Qe(h),null,{signal:t}))[0];if(yield,m==null||f==null)return{candidates:[]};const y=await this._searchFeatures(fe(f.toJSON()));yield;const x=new A(y,l,this);this._executeObjectIdsQuery(x),yield,this._executeTimeQuery(x),yield,this._executeAttributesQuery(x),yield,yield*this._executeGeometryQueryForSnapping(x),yield;const I=m.toJSON(),w=o?C(I,this.spatialReference):I,S=o?Math.max(h.xmax-h.xmin,h.ymax-h.ymin)/2:s;return x.createSnappingResponse({...e,point:w,distance:S},l.returnZ,i.spatialReference)}async _getBounds(e,t,i){const s=Rt(bt(),vt);return await this.featureStore.forEachBounds(e,a=>At(s,a)),Bi(s,t,i,this.spatialReference,this.hasZ)}_getFullExtent(){return this._fullExtentPromise||="getFullExtent"in this.featureStore&&this.featureStore.getFullExtent?Promise.resolve(this.featureStore.getFullExtent(this.spatialReference)):this._getAllFeatures().then(e=>this._getBounds(e,this.spatialReference,this.spatialReference)),this._fullExtentPromise}async _getAllFeaturesQueryEngineResult(e){return new A(await this._getAllFeatures(),e,this)}async _getAllFeatures(){if(this._allFeaturesPromise==null){const i=[];this._allFeaturesPromise=(async()=>await this.featureStore.forEach(s=>i.push(s)))().then(()=>K(i))}const e=this._allFeaturesPromise,t=await e;return e===this._allFeaturesPromise?t.slice():this._getAllFeatures()}async*_executeQuery(e,t){e=X(e),e=await Pe(e,this.definitionExpression,this.spatialReference),yield,e=await _e(e,{availableFields:this.availableFields,fieldsIndex:this.fieldsIndex,geometryType:this.geometryType,spatialReference:this.spatialReference}),yield,e={...e,...t};const i=yield*this._executeSceneFilterQuery(e);yield;const s=yield*this._executeGeometryQuery(e,i);return yield,this._executeAggregateIdsQuery(s),yield,this._executeObjectIdsQuery(s),yield,this._executeTimeQuery(s),yield,this._executeAttributesQuery(s),s}async*_executeSceneFilterQuery(e){if(e.sceneFilter==null)return null;const{outSR:t,returnGeometry:i,returnCentroid:s}=e,a=this.featureStore.featureSpatialReference,r=e.sceneFilter.geometry,l=a==null||G(a,r.spatialReference)?r:C(r,a);if(!l)return null;const o=i||s,u=L(t)&&!G(this.spatialReference,t)&&o?async f=>this._project(f,t):f=>f;yield;const c=this.featureAdapter,d=await this._searchFeatures(fe(l));if(yield,e.sceneFilter.spatialRelationship==="disjoint"){if(!d.length)return null;const f=new Set;for(const _ of d)f.add(c.getObjectId(_));const y=await this._getAllFeatures();yield;const x=await Y("esriSpatialRelDisjoint",l,this.geometryType,this.hasZ,this.hasM);yield;const I=_=>!f.has(c.getObjectId(_))||x(c.getGeometry(_)),w=yield*this._runSpatialFilter(y,I);yield;const S=new A(w,e,this);return await u(S)}if(!d.length)return new A([],e,this);if(this._canExecuteSinglePass(l,e))return await u(new A(d,e,this));const h=await Y("esriSpatialRelContains",l,this.geometryType,this.hasZ,this.hasM);yield;const m=yield*this._runSpatialFilter(d,f=>h(c.getGeometry(f)));return yield,await u(new A(m,e,this))}async*_executeGeometryQuery(e,t){if(t!=null&&t.items.length===0)return t;const{geometry:i,outSR:s,returnGeometry:a,returnCentroid:r}=e,l=t?null:this._getCacheKey(e),o=l?this._cache.get(l):null;if(o)return new A(o,e,this);const u=L(s)&&!G(this.spatialReference,s),c=a||r,d=async S=>(u&&c&&await this._project(S,s),l&&this._cache.put(l,S.items),S),h=this.featureStore.featureSpatialReference,m=!i||h==null||G(h,i.spatialReference)?i:C(i,h);if(!m)return await d(t??await this._getAllFeaturesQueryEngineResult(e));yield;const f=this.featureAdapter;let y=await this._searchFeatures(fe(i));yield;const x=e.spatialRel??"esriSpatialRelIntersects";if(x==="esriSpatialRelDisjoint"){if(!y.length)return await d(t??await this._getAllFeaturesQueryEngineResult(e));const S=new Set;for(const R of y)S.add(f.getObjectId(R));let _;t!=null?_=t.items:(yield,_=await this._getAllFeatures(),yield);const g=await Y(x,m,this.geometryType,this.hasZ,this.hasM);yield;const F=R=>!S.has(f.getObjectId(R))||g(f.getGeometry(R)),p=yield*this._runSpatialFilter(_,F);yield;const T=new A(p,e,this);return await d(T)}if(t!=null){const S=new Et;y=y.filter(_=>$t(t.items,_,t.items.length,S)>=0)}if(!y.length){const S=new A([],e,this);return l&&this._cache.put(l,S.items),S}if(this._canExecuteSinglePass(m,e))return await d(new A(y,e,this));const I=await Y(x,m,this.geometryType,this.hasZ,this.hasM);yield;const w=yield*this._runSpatialFilter(y,S=>I(f.getGeometry(S)));return yield,await d(new A(w,e,this))}_executeAggregateIdsQuery(e){if(e.items.length===0||!e.query.aggregateIds?.length||this.aggregateAdapter==null)return;const t=new Set;for(const s of e.query.aggregateIds)this.aggregateAdapter.getFeatureObjectIds(s).forEach(a=>t.add(a));const i=this.featureAdapter.getObjectId;e.items=e.items.filter(s=>t.has(i(s)))}_executeObjectIdsQuery(e){if(e.items.length===0||!e.query.objectIds?.length)return;const t=new Set(e.query.objectIds),i=this.featureAdapter.getObjectId;e.items=e.items.filter(s=>t.has(i(s)))}_executeTimeQuery(e){if(e.items.length===0)return;const t=Gi(this.timeInfo,e.query.timeExtent,this.featureAdapter);t!=null&&(e.items=e.items.filter(t))}_executeAttributesQuery(e){if(e.items.length===0)return;const t=Z(e.query.where,this.fieldsIndex);if(t){if(!t.isStandardized)throw new TypeError("Where clause is not standardized");e.items=e.items.filter(i=>t.testFeature(i,this.featureAdapter))}}async*_executeGeometryQueryForSnapping(e){const{query:t}=e,{spatialRel:i}=t;if(!e?.items?.length||!t.geometry||!i)return;const s=await Y(i,t.geometry,this.geometryType,this.hasZ,this.hasM);yield;const a=this.featureAdapter,r=o=>s(a.getGeometry(o)),l=yield*this._runSpatialFilter(e.items,r);e.items=l}*_runSpatialFilter(e,t){if(!t)return e;if(this._frameTask==null)return e.filter(a=>t(a));let i=yield;const s=new Array;for(const a of e)t(a)&&s.push(a),i.madeProgress(),i.done&&(i=yield);return s}_filterLatest(e){const{trackIdField:t,startTimeField:i,endTimeField:s}=this.timeInfo,a=s||i,r=new Map,l=this.featureAdapter.getAttribute;for(const o of e.items){const u=l(o,t),c=l(o,a),d=r.get(u);(!d||c>l(d,a))&&r.set(u,o)}e.items=Array.from(r.values())}_getCacheKey(e){const{geometry:t,spatialRel:i,returnGeometry:s,returnCentroid:a,outSR:r,resultType:l,cacheHint:o}=e;if(l!=="tile"&&!o)return null;const u=s||a;return L(r)&&!G(this.spatialReference,r)&&u?JSON.stringify([t,i,r]):JSON.stringify([t,i])}_canExecuteSinglePass(e,t){const{spatialRel:i}=t;return tt(e)&&(i==="esriSpatialRelEnvelopeIntersects"||this.geometryType==="esriGeometryPoint"&&(i==="esriSpatialRelIntersects"||i==="esriSpatialRelContains"))}async _project(e,t){if(!t||G(this.spatialReference,t))return e;const i=this.featureAdapter,s=Vt()?await this._getFullExtent():void 0,a=await Zt(e.items.map(r=>Q(this.geometryType,this.hasZ,this.hasM,i.getGeometry(r))),this.spatialReference,t,{areaOfInterestExtent:s});return e.items=K(a.map((r,l)=>i.cloneWithGeometry(e.items[l],Mt(r,this.hasZ,this.hasM)))),e}async _searchFeatures(e){const t=new Set;await Promise.all(e.map(s=>this.featureStore.forEachInBounds(s,a=>t.add(a))));const i=Array.from(t.values());return t.clear(),i}async*_executeQueryForStatistics(e,t){e=X(e);try{e=await Pe(e,this.definitionExpression,this.spatialReference),yield,e=await $i(e,t,{availableFields:this.availableFields,fieldsIndex:this.fieldsIndex,geometryType:this.geometryType,spatialReference:this.spatialReference}),yield;const i=yield*this._executeSceneFilterQuery(e);yield;const s=yield*this._executeGeometryQuery(e,i);return yield,this._executeAggregateIdsQuery(s),yield,this._executeObjectIdsQuery(s),yield,this._executeTimeQuery(s),yield,this._executeAttributesQuery(s),yield,s}catch(i){if(i!==O)throw i;return new A([],e,this)}}get test(){}}function fe(n){if(tt(n)){if(Se(n))return[ze(Math.min(n.xmin,n.xmax),Math.min(n.ymin,n.ymax),Math.max(n.xmin,n.xmax),Math.max(n.ymin,n.ymax))];if(Fe(n))return n.rings.map(e=>ze(Math.min(e[0][0],e[2][0]),Math.min(e[0][1],e[2][1]),Math.max(e[0][0],e[2][0]),Math.max(e[0][1],e[2][1])))}return[Gt(Qt(),n)]}function Bi(n,e,t,i,s){const a={xmin:n[0],ymin:n[1],xmax:n[3],ymax:n[4],spatialReference:ee(i)};s&&isFinite(n[2])&&isFinite(n[5])&&(a.zmin=n[2],a.zmax=n[5],a.hasZ=!0);const r=C(a,e,t);if(r.spatialReference=ee(t),r.xmax-r.xmin===0){const l=oe(r.spatialReference);r.xmin-=l,r.xmax+=l}if(r.ymax-r.ymin===0){const l=oe(r.spatialReference);r.ymin-=l,r.ymax+=l}if(s&&r.zmin!=null&&r.zmax!=null&&r.zmax-r.zmin===0){const l=oe(r.spatialReference);r.zmin-=l,r.zmax+=l}return r}export{A as E,Y as I,Ji as W,Bi as Y,ee as h,Gi as l};
