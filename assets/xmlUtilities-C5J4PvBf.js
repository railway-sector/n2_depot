const __vite__mapDeps=(i,m=__vite__mapDeps,d=(m.f||(m.f=["assets/densifyOperator-CknJhA0u.js","assets/index-B9VIL3e7.js","assets/index-ClKQjglF.css","assets/Point2D-D6cTW4Xl.js","assets/ProjectionTransformation-SnYCA3Wg.js","assets/Envelope2D-DdeZvC4f.js","assets/Transformation2D-CiTBrf8G.js","assets/SimpleGeometryCursor-B92kdZ15.js","assets/OperatorDefinitions-DP7_WWTp.js","assets/jsonConverter-3sScDEQk.js","assets/operatorDensify-Dmw6ts6-.js","assets/apiConverter-k_pJ1MRL.js","assets/differenceOperator-DHJD9M-i.js","assets/lengthOperator-ivQu0sNN.js"])))=>i.map(i=>d[i]);
import{bx as Ce,W as ee,sf as be,bl as ae,s as H,i3 as Y,aB as C,az as Q,H as we,hn as De,V as _e,a3 as ze,sg as $e,e as I,m as b,y as ve,h as ue,bu as He,_ as te,P as Me,h2 as Je,cl as Ne,o as Ee,ce as Oe}from"./index-B9VIL3e7.js";import{y as Se,C as We,s as Le,r as Ae,a as ke,u as qe,N as fe,p as Ge,l as je,d as Ve,j as Ue,g as Qe,v as de,D as me,h as Xe,b as Ke,U as Ye,c as Ze,e as et,f as tt,q as it,W as nt,z as rt,B as pe,i as st,k as ye}from"./RasterJobHandlerMixin-Bkz31ZHT.js";import{T as re,R as at,l as ot,N as Te,D as lt,a as ct,b as ut,c as ht,k as ft,O as dt}from"./RasterSymbolizer-CnQQqByY.js";import{t as N,n as mt}from"./datasetUtils-DdDUWBI2.js";import{QueueProcessor as pt}from"./QueueProcessor-BFb5p1el.js";import{$ as K,j as oe,W as ge,f as xe,c as yt,n as se,H as Z,r as gt,i as xt,C as It,Q as le}from"./rasterProjectionHelper-C71OE4Dv.js";import{r as ce,p as Rt,T as bt}from"./rasterFunctionHelper-CSJY8bkL.js";let wt=class{constructor(e=15e3,i=5e3){this._timer=null,this._cachedBlocks=new Map,this._size=-1,this._duration=e,this._interval=Math.min(e,i)}decreaseRefCount(e,i){const r=e+"/"+i,t=this._cachedBlocks;if(t.has(r)){const n=t.get(r);return n.refCount--,n.refCount<=0&&(t.delete(r),n.controller&&n.controller.abort()),n.refCount}return 0}getBlock(e,i){const r=e+"/"+i,t=this._cachedBlocks;if(t.has(r)){const n=t.get(r);return n.ts=Date.now(),n.refCount++,t.delete(r),t.set(r,n),n.block}return null}putBlock(e,i,r,t){const n=this._cachedBlocks,a=e+"/"+i;if(n.has(a)){const s=n.get(a);s.ts=Date.now(),s.refCount++}else n.set(a,{block:r,ts:Date.now(),refCount:1,controller:t});this._trim(),this._updateTimer()}deleteBlock(e,i){const r=this._cachedBlocks,t=e+"/"+i;r.has(t)&&r.delete(t)}updateMaxSize(e){this._size=e,this._trim()}empty(){this._cachedBlocks.clear(),this._clearTimer()}getCurrentSize(){return this._cachedBlocks.size}_updateTimer(){if(this._timer!=null)return;const e=this._cachedBlocks;this._timer=setInterval(()=>{const i=Array.from(e),r=Date.now();for(let t=0;t<i.length&&i[t][1].ts<=r-this._duration;t++)e.delete(i[t][0]);e.size===0&&this._clearTimer()},this._interval)}_trim(){const e=this._cachedBlocks;if(this._size===-1||this._size>=e.size)return;const i=Array.from(e);for(let r=0;r<i.length-this._size;r++)e.delete(i[r][0])}_clearTimer(){this._timer!=null&&(clearInterval(this._timer),this._timer=null)}};const ne=new Map,W=new wt;function _t(f,e,i){const r=[];return e!=null&&r.push(`sliceId=${e}`),i!=null&&r.push(`bandIds=${i.join(",")}`),r.length?`${f}?${r.join("&")}`:f}function vt(f,e,i){const r=ne.get(f);if(!r)return e==null?W.decreaseRefCount(f,i):0;if(e==null||r[e]==null)return W.decreaseRefCount(f,i);const t=r[e]?.cache,n=t?.get(i);if(t&&n){if(n.refCount--,n.refCount===0){t.delete(i);for(let a=0;a<r.length;a++)r[a]?.cache.delete(i);n.controller&&n.controller.abort()}return n.refCount}return 0}function St(f,e,i){const r=ne.get(f);if(!r)return e==null?W.getBlock(f,i):null;if(e==null||r[e]==null){for(let n=0;n<r.length;n++){const a=r[n]?.cache.get(i);if(a)return a.refCount++,a.block}return W.getBlock(f,i)}const t=r[e]?.cache.get(i);if(t)return t.refCount++,t.block;for(let n=0;n<r.length;n++){if(n===e||!r[n])continue;const a=r[n]?.cache,s=a?.get(i);if(a&&s)return s.refCount++,a.set(i,s),s.block}return null}function kt(f,e,i,r,t=null){const n=ne.get(f);if(!n)return void(e==null&&W.putBlock(f,i,r,t));if(e==null||n[e]==null)return void W.putBlock(f,i,r,t);const a={refCount:1,block:r,isResolved:!1,isRejected:!1,controller:t};r.then(()=>a.isResolved=!0).catch(()=>a.isRejected=!0),n[e]?.cache.set(i,a)}function Tt(f,e,i){const r=ne.get(f);r?e!=null&&r[e]!=null?r[e]?.cache.delete(i):W.deleteBlock(f,i):e==null&&W.deleteBlock(f,i)}const Ie=8,Bt=256;let Pt=0,_=class extends Ce{constructor(){super(...arguments),this._tileFetchQueue=new pt({concurrency:32,process:(e,i)=>this._fetchRawTile(e.pyramidLevel,e.row,e.col,{...e.options,signal:i})}),this.datasetName=null,this.datasetFormat=null,this.hasUniqueSourceStorageInfo=!0,this.rasterInfo=null,this.ioConfig={sampling:"closest"}}normalizeCtorArgs(e){return e?.ioConfig&&(e={...e,ioConfig:{resolution:null,bandIds:null,sampling:"closest",tileInfo:ee.create(),...e.ioConfig}}),e}get _isGlobalWrappableSource(){const{rasterInfo:e}=this,i=K(e.spatialReference);return i!=null&&e.extent.width>=i/2}get _hasNoneOrGCSShiftTransform(){const{transform:e}=this.rasterInfo;return e==null||e.type==="gcs-shift"}set rasterJobHandler(e){this._set("rasterJobHandler",e),N(this)&&this.primaryRasters?.rasters?.forEach(i=>i.rasterJobHandler=e)}get rasterId(){return this.url||"rasterId-"+Pt++}set url(e){this._set("url",be(e,ae.getLogger(this)))}async open(e){return this._openPromise??=oe().then(()=>this._open(e)),this._openPromise}async fetchTile(e,i,r,t={}){const n=t.tileInfo||this.rasterInfo.storageInfo.tileInfo,a=this.getTileExtentFromTileInfo(e,i,r,n);if(!a)throw new H("imagery-tile:out-of-bounds","Level for fetch tile out of range");return t={noClip:!0,...t},this.fetchPixels(a,n.size[0],n.size[1],t)}async identify(e,i={}){e=Y(C,e).clone().normalize();const{multidimensionalDefinition:r,timeExtent:t}=i,{rasterInfo:n}=this,{hasMultidimensionalTranspose:a,multidimensionalInfo:s}=n;let{transposedVariableName:l}=i;const o=s!=null&&a&&(t!=null||Se(r));o&&!l&&(l=r!=null&&r.length>0?r[0].variableName??void 0:s.variables[0].name,i={...i,transposedVariableName:l}),i=this._getRequestOptionsWithSliceId(i);const{spatialReference:c,extent:u}=n,{datumTransformation:d}=i;let h=ge(e,c,d);if(!u.intersects(h))return{location:h,value:null};if(n.transform!=null){const P=n.transform.inverseTransform(h);if(!n.nativeExtent.intersects(P))return{location:P,value:null};h=P}let p=0;const g=l!=null&&s!=null&&n.hasMultidimensionalTranspose;if(N(this)){const P=this.primaryRasters.rasters[0];if(g)return P.identify(h,i);const{pixelSize:L}=n,S=3,$=L.x*S/2,A=L.y*S/2,q=new Q({xmin:h.x-$,xmax:h.x+$,ymin:h.y-A,ymax:h.y+A,spatialReference:c}),G={interpolation:"nearest",multidimensionalDefinition:r,sliceId:i.sliceId,bandIds:i.bandIds},{pixelBlock:T}=await P.fetchPixels(q,S,S,G),{pixelBlock:k}=await this.fetchPixels(q,S,S,G);if(T==null)return{location:h,value:null};const F=Math.floor(S*S*.5),M=!T.mask||T.mask[F]?T.pixels.map(D=>D[F]):null;let E;return k!=null&&(E=!k.mask||k.mask[F]?k.pixels.map(D=>D[F]):void 0),{location:h,value:M,processedValue:E,pyramidLevel:0}}if(!g){if(i.srcResolution)p=xe(i.srcResolution,n,this.ioConfig.sampling).pyramidLevel;else if(p=await this.computeBestPyramidLevelForLocation(e,i),p==null)return{location:h,value:null}}const R=this.identifyPixelLocation(h,p,null,g);if(R===null)return{location:h,value:null};const{row:m,col:y,rowOffset:x,colOffset:w,blockWidth:v}=R,B=await this._tileFetchQueue.push({pyramidLevel:p,row:m,col:y,options:i},{signal:i.signal});if(!B?.pixels?.length)return{location:h,value:null};const z=x*v+w;return this._processIdentifyResult(B,{srcLocation:h,position:z,pyramidLevel:p,useTransposedTile:!!g,requestSomeSlices:o,identifyOptions:i})}async fetchPixels(e,i,r,t={}){e=yt(e),t=this._getRequestOptionsWithSliceId(t);const{_hasNoneOrGCSShiftTransform:n}=this;if(t.requestRawData&&n)return this._fetchPixels(e,i,r,t);const a=K(e.spatialReference),s=se(e);if(a==null||s===0||s===1&&this._isGlobalWrappableSource&&n)return this._fetchPixels(e,i,r,t);if(s>=3)return{extent:e,pixelBlock:null};const l=[],{xmin:o,xmax:c}=e,u=Math.round(a/(c-o)*i),d=u-Math.round((a/2-o)/(c-o)*i);let h=0;const p=[];for(let y=0;y<=s;y++){const x=new Q({xmin:y===0?o:-a/2,xmax:y===s?c-a*y:a/2,ymin:e.ymin,ymax:e.ymax,spatialReference:e.spatialReference}),w=y===0?u-d:y===s?i-h:u;h+=w,p.push(w);const v=t.disableWrapAround&&y>0?null:this._fetchPixels(x,w,r,t);l.push(v)}const g=(await Promise.all(l)).map(y=>y?.pixelBlock);let R=null;const m={width:i,height:r};return this.rasterJobHandler?R=(await this.rasterJobHandler.mosaicAndTransform({srcPixelBlocks:g,srcMosaicSize:m,destDimension:null,coefs:null,sampleSpacing:null,interpolation:"nearest",alignmentInfo:null,blockWidths:p},t)).pixelBlock:R=re(g,m,{blockWidths:p}),{extent:e,srcExtent:Z(e,this.rasterInfo.spatialReference,t.datumTransformation),pixelBlock:R}}async fetchRawPixels(e,i,r,t={}){i={x:Math.floor(i.x),y:Math.floor(i.y)};const n=await this._fetchRawTiles(e,i,r,t),{nativeExtent:a,nativePixelSize:s,storageInfo:l}=this.rasterInfo,o=2**e,c=s.x*o,u=s.y*o,d=new Q({xmin:a.xmin+c*i.x,xmax:a.xmin+c*(i.x+r.width-1),ymin:a.ymax-u*(i.y+r.height-1),ymax:a.ymax-u*i.y,spatialReference:a.spatialReference});if(!n)return{extent:d,srcExtent:d,pixelBlock:null};const{pixelBlocks:h,mosaicSize:p}=n;if(h.length===1&&h[0]!=null&&h[0].width===r.width&&h[0].height===r.height)return{extent:d,srcExtent:d,pixelBlock:n.pixelBlocks[0]};const g=e>0?l.pyramidBlockWidth:l.blockWidth,R=e>0?l.pyramidBlockHeight:l.blockHeight,m={x:i.x%g,y:i.y%R};let y;return this.rasterJobHandler?y=(await this.rasterJobHandler.mosaicAndTransform({srcPixelBlocks:h,srcMosaicSize:p,destDimension:r,clipOffset:m,clipSize:r,coefs:null,sampleSpacing:null,interpolation:t.interpolation,alignmentInfo:null,blockWidths:null},t)).pixelBlock:y=re(h,p,{clipOffset:m,clipSize:r}),{extent:d,srcExtent:d,pixelBlock:y}}fetchRawTile(e,i,r,t){throw new H("BaseRaster:read-not-implemented","fetchRawTile() is not implemented")}computeExtent(e){return Z(this.rasterInfo.extent,e)}decodePixelBlock(e,i){return!this.rasterJobHandler||i.useCanvas?at(e,i):this.rasterJobHandler.decode({data:e,options:i})}async request(e,i,r=0){const{customFetchParameters:t}=this.ioConfig,{range:n,query:a,headers:s}=i;r=r??i.retryCount??this.ioConfig.retryCount;const l=n?{Range:`bytes=${n.from}-${n.to}`}:null;try{return await we(e,{...i,query:{...a,...t},headers:{...s,...l}})}catch(o){if(r>0)return r--,this.request(e,i,r);throw o}}getSliceIndex(e){const{multidimensionalInfo:i}=this.rasterInfo;return i==null||e==null||e.length===0?null:We(e,i)}getTileExtentFromTileInfo(e,i,r,t){const n=t.lodAt(e);return n?this.getTileExtent({x:n.resolution,y:n.resolution},i,r,t.origin,t.spatialReference,t.size):null}updateTileInfo(){const{storageInfo:e,spatialReference:i,extent:r,pixelSize:t}=this.rasterInfo,{pyramidResolutions:n}=e;if(!e.tileInfo){const a=[],s=e.maximumPyramidLevel||0;let l=(t.x+t.y)/2,o=1/.0254*96*l;for(let u=0;u<=s&&(a.unshift(new De({level:s-u,resolution:l,scale:o})),u!==s);u++)if(n){const d=(n[u].x+n[u].y)/2;o*=d/l,l=d}else l*=2,o*=2;const c=new C({x:r.xmin,y:r.ymax,spatialReference:i});e.tileInfo=new ee({origin:c,size:[e.blockWidth,e.blockHeight],spatialReference:i,lods:a}),e.isVirtualTileInfo=!0}}createRemoteDatasetStorageInfo(e,i=512,r=512,t){const{width:n,height:a,nativeExtent:s,pixelSize:l,spatialReference:o}=e,c=new C({x:s.xmin,y:s.ymax,spatialReference:o});t==null&&(t=Math.max(0,Math.round(Math.log(Math.max(n,a))/Math.LN2-8)));const u=this.computeBlockBoundary(s,512,512,{x:s.xmin,y:s.ymax},[l],t);e.storageInfo=new ot({blockWidth:i,blockHeight:r,pyramidBlockWidth:i,pyramidBlockHeight:r,origin:c,firstPyramidLevel:1,maximumPyramidLevel:t,blockBoundary:u})}async computeBestPyramidLevelForLocation(e,i={}){return 0}computeBlockBoundary(e,i,r,t,n,a=0,s=2){if(n.length===1&&a>0){n=[...n];let{x:u,y:d}=n[0];for(let h=0;h<a;h++)u*=s,d*=s,n.push({x:u,y:d})}const l=[],{x:o,y:c}=t;for(let u=0;u<n.length;u++){const{x:d,y:h}=n[u];l.push({minCol:Math.floor((e.xmin-o+.1*d)/i/d),maxCol:Math.floor((e.xmax-o-.1*d)/i/d),minRow:Math.floor((c-e.ymax+.1*h)/r/h),maxRow:Math.floor((c-e.ymin-.1*h)/r/h)})}return l}getPyramidPixelSize(e){const{nativePixelSize:i}=this.rasterInfo,{pyramidResolutions:r,pyramidScalingFactor:t}=this.rasterInfo.storageInfo;if(e===0)return i;if(r!=null&&r.length)return r[e-1];const n=t**e;return{x:i.x*n,y:i.y*n}}identifyPixelLocation(e,i,r,t){const{spatialReference:n,nativeExtent:a,storageInfo:s}=this.rasterInfo,{maximumPyramidLevel:l,origin:o,transposeInfo:c}=s,u=t&&c!=null?c.tileSize[0]:s.blockWidth,d=t&&c!=null?c.tileSize[1]:s.blockHeight,h=ge(e,n,r);if(!a.intersects(h)||i<0||i>l)return null;const p=this.getPyramidPixelSize(i),{x:g,y:R}=p,m=(o.y-h.y)/R/d,y=(h.x-o.x)/g/u,x=Math.min(d-1,Math.floor((m-Math.floor(m))*d)),w=Math.min(u-1,Math.floor((y-Math.floor(y))*u));return{pyramidLevel:i,row:Math.floor(m),col:Math.floor(y),rowOffset:x,colOffset:w,blockWidth:u,srcLocation:h}}getTileExtent(e,i,r,t,n,a){const[s,l]=a,o=t.x+r*s*e.x,c=o+s*e.x,u=t.y-i*l*e.y,d=u-l*e.y;return new Q({xmin:o,xmax:c,ymin:d,ymax:u,spatialReference:n})}getBlockWidthHeight(e){return{blockWidth:e>0?this.rasterInfo.storageInfo.pyramidBlockWidth:this.rasterInfo.storageInfo.blockWidth,blockHeight:e>0?this.rasterInfo.storageInfo.pyramidBlockHeight:this.rasterInfo.storageInfo.blockHeight}}isBlockOutside(e,i,r){const t=this.rasterInfo.storageInfo.blockBoundary[e];return!t||t.maxRow<i||t.maxCol<r||t.minRow>i||t.minCol>r}updateImageSpaceRasterInfo(e){const{pixelSize:i}=e,{width:r,height:t}=e,n=_e.WebMercator;e.spatialReference=n,e.extent=e.nativeExtent=new Q({xmin:-.5,ymax:.5,xmax:r-.5,ymin:.5-t,spatialReference:n}),e.isPseudoSpatialReference=!0,e.transform=null,e.pixelSize=new C({x:1,y:1,spatialReference:n});const{extent:a,storageInfo:s}=e;if(s){s.origin=new C({x:a.xmin,y:a.ymax,spatialReference:n});const{pyramidResolutions:l,tileInfo:o}=s;if(l&&l.forEach(c=>{c.x/=i.x,c.y/=i.y}),o){o.origin=s.origin;const c=(e.nativePixelSize.x+e.nativePixelSize.y)/2;o.lods.forEach((u,d)=>{u.resolution=c*2**d,u.scale=96*u.resolution/.0254})}}}async _fetchPixels(e,i,r,t={}){let n=se(e);if(n>=2)return{extent:e,pixelBlock:null};const a=this._getSourceDataInfo(e,i,r,t),{pyramidLevel:s,srcResolution:l,srcExtent:o,srcWidth:c,srcHeight:u,ul:d}=a;if(c===0||u===0)return{extent:e,srcExtent:o,pixelBlock:null};const{rasterInfo:h}=this,p=h.transform,g=p?.type==="gcs-shift",R=K(e.spatialReference)!=null;!g&&R||(n=se(a.srcExtent,g));const m=await this._fetchRawTiles(s,d,{width:c,height:u,wrapCount:n},t);if(!m)return{extent:e,srcExtent:o,pixelBlock:null};const y=h.storageInfo,x=s>0?y.pyramidBlockWidth:y.blockWidth,w=s>0?y.pyramidBlockHeight:y.blockHeight;let{x:v,y:B}=h.pixelSize;if(s>0){const{pyramidResolutions:J,pyramidScalingFactor:Fe}=y;if(J!=null&&J[s-1])({x:v,y:B}=J[s-1]);else{const he=Fe**s;v*=he,B*=he}}const z=h.spatialReference,P=new C({x:v,y:B,spatialReference:z}),L=x===c&&w===u&&d.x%x===0&&d.y%w===0,S=new C({x:(e.xmax-e.xmin)/i,y:(e.ymax-e.ymin)/r,spatialReference:e.spatialReference}),$=!e.spatialReference.equals(z),A=z.isGeographic?1e-9:1e-4,{datumTransformation:q}=t;if(!$&&L&&m.pixelBlocks.length===1&&x===i&&w===r&&Ft(l,S,A))return{extent:e,srcExtent:o,srcTilePixelSize:P,pixelBlock:m.pixelBlocks[0]};const G=R&&K(o.spatialReference)!=null&&this._hasNoneOrGCSShiftTransform,T=t.requestProjectedLocalDirections&&this.rasterInfo.dataType.startsWith("vector");T&&!this.rasterJobHandler&&await oe();const k=this.rasterJobHandler?await this.rasterJobHandler.getProjectionOffsetGrid({projectedExtent:e,srcBufferExtent:m.extent,pixelSize:S.toJSON(),datumTransformation:q,rasterTransform:p,hasWrapAround:n>0||G,isAdaptive:this.ioConfig.optimizeProjectionAccuracy!==!1,includeGCSGrid:T},t):gt({projectedExtent:e,srcBufferExtent:m.extent,pixelSize:S,datumTransformation:q,rasterTransform:p,hasWrapAround:n>0||G,isAdaptive:!1,includeGCSGrid:T});let F;const M=!t.requestRawData,E={rows:k.spacing[0],cols:k.spacing[1]},D=this._hasNoneOrGCSShiftTransform?this._getRasterTileAlignmentInfo(s,m.extent.xmin):void 0,{pixelBlocks:O,mosaicSize:j,isPartiallyFilled:X}=m;let V=null;if(this.rasterJobHandler)({pixelBlock:F,localNorthDirections:V}=await this.rasterJobHandler.mosaicAndTransform({srcPixelBlocks:O,srcMosaicSize:j,destDimension:M?{width:i,height:r}:null,coefs:M?k.coefficients:null,sampleSpacing:M?E:null,projectDirections:T,gcsGrid:T?k.gcsGrid:null,isUV:this.rasterInfo.dataType==="vector-uv",interpolation:t.interpolation,alignmentInfo:D,blockWidths:null},t));else{const J=re(O,j,{alignmentInfo:D});F=M?Te(J,{width:i,height:r},k.coefficients,E,t.interpolation):J,T&&k.gcsGrid&&(V=lt({width:i,height:r},k.gcsGrid),F=ct(F,this.rasterInfo.dataType,V))}return t.requestRawData||T?{extent:e,srcExtent:o,srcTilePixelSize:P,pixelBlock:F,transformGrid:k,localNorthDirections:V,isPartiallyFilled:X}:{extent:e,srcExtent:o,srcTilePixelSize:P,pixelBlock:F}}async _fetchRawTiles(e,i,r,t){const{origin:n,blockBoundary:a}=this.rasterInfo.storageInfo,{blockWidth:s,blockHeight:l}=this.getBlockWidthHeight(e);let{x:o,y:c}=i,{width:u,height:d,wrapCount:h}=r;const p=this._getRasterTileAlignmentInfo(e,0);t.buffer&&(o-=t.buffer.cols,c-=t.buffer.rows,u+=2*t.buffer.cols,d+=2*t.buffer.rows);let g=0,R=0,m=0;h&&p!=null&&({worldColumnCountFromOrigin:R,originColumnOffset:m,rightPadding:g}=p,R*p.blockWidth-g>=o+u&&(g=0));const y=Math.floor(o/s),x=Math.floor(c/l),w=Math.floor((o+u+g-1)/s),v=Math.floor((c+d+g-1)/l),B=a[e];if(!B)return null;const{minRow:z,minCol:P,maxCol:L,maxRow:S}=B;if(h===0&&(v<z||w<P||x>S||y>L))return null;const $=new Array;let A=!1;const q=this.ioConfig.allowPartialFill==null?t.allowPartialFill:this.ioConfig.allowPartialFill;for(let D=x;D<=v;D++)for(let O=y;O<=w;O++){let j=O;if(!t.disableWrapAround&&h&&p!=null&&R<=O&&(j=O-R-m),D>=z&&j>=P&&S>=D&&L>=j){const X=this._tileFetchQueue.push({pyramidLevel:e,row:D,col:j,options:t},{signal:t.signal});q?$.push(new Promise(V=>{X.then(J=>V(J)).catch(()=>{A=!0,V(null)})})):$.push(X)}else $.push(Promise.resolve(null))}if($.length===0)return null;const G=await Promise.all($),T={height:(v-x+1)*l,width:(w-y+1)*s},{spatialReference:k}=this.rasterInfo,F=this.getPyramidPixelSize(e),{x:M,y:E}=F;return{extent:new Q({xmin:n.x+y*s*M,xmax:n.x+(w+1)*s*M,ymin:n.y-(v+1)*l*E,ymax:n.y-x*l*E,spatialReference:k}),pixelBlocks:G,mosaicSize:T,isPartiallyFilled:A}}_fetchRawTile(e,i,r,t){const{storageInfo:n}=this.rasterInfo,a=n.transposeInfo!=null&&!!t.transposedVariableName;if(!a){const d=n.blockBoundary[e];if(!d)return Promise.resolve(null);const{minRow:h,minCol:p,maxCol:g,maxRow:R}=d;if(i<h||r<p||i>R||r>g)return Promise.resolve(null)}const s=a?t.transposeVariableName:t.sliceId,l=this.rasterInfo.storageInfo.isBsqTile?t.bandIds:null,o=_t(this.rasterId,s,l),c=`${e}/${i}/${r}`;let u=St(o,t.registryId,c);if(u==null){const d=new AbortController;u=this.fetchRawTile(e,i,r,{...t,signal:d.signal}),kt(o,t.registryId,c,u,d),u.catch(()=>Tt(o,t.registryId,c))}return t.signal&&ze(t,()=>{vt(o,t.registryId,c)}),u}_computeMagDirValues(e){const{bandCount:i,dataType:r}=this.rasterInfo;if(!(i===2&&r==="vector-magdir"||r==="vector-uv")||e?.length!==2||!e[0]?.length)return null;const t=e[0].length;if(r==="vector-magdir"){const o=e[1].map(c=>(c+360)%360);return[e[0],o]}const[n,a]=e,s=[],l=[];for(let o=0;o<t;o++){const[c,u]=ut([n[o],a[o]]);s.push(c),l.push(u)}return[s,l]}_getRasterTileAlignmentInfo(e,i){return this._rasterTileAlignmentInfo==null&&(this._rasterTileAlignmentInfo=xt(this.rasterInfo)),this._rasterTileAlignmentInfo.pyramidsInfo==null?null:{startX:i,halfWorldWidth:this._rasterTileAlignmentInfo.halfWorldWidth,hasGCSSShiftTransform:this._rasterTileAlignmentInfo.hasGCSSShiftTransform,...this._rasterTileAlignmentInfo.pyramidsInfo[e]}}_getSourceDataInfo(e,i,r,t={}){const n={datumTransformation:t.datumTransformation,pyramidLevel:0,pyramidResolution:null,srcExtent:null,srcHeight:0,srcResolution:null,srcWidth:0,ul:{x:0,y:0}};t.srcResolution&&(n.srcResolution=t.srcResolution,this._updateSourceDataInfo(e,n));const a=this.rasterInfo.storageInfo.maximumPyramidLevel||0,{srcWidth:s,srcHeight:l,pyramidLevel:o}=n,c=s/i,u=l/r,d=o<a&&c*u>=16,h=o===a&&this._requireTooManySrcTiles(s,l,i,r);if(d||h||s===0||l===0){const p=new C({x:(e.xmax-e.xmin)/i,y:(e.ymax-e.ymin)/r,spatialReference:e.spatialReference});let g=It(p,this.rasterInfo.spatialReference,e,n.datumTransformation);const R=!g||t.srcResolution&&g.x+g.y<t.srcResolution.x+t.srcResolution.y;if(d&&t.srcResolution&&R){const m=Math.round(Math.log(Math.max(c,u))/Math.LN2)-1;if(a-o+3>=m){const y=2**m;g={x:t.srcResolution.x*y,y:t.srcResolution.y*y}}}g&&(n.srcResolution=g,this._updateSourceDataInfo(e,n))}return this._requireTooManySrcTiles(n.srcWidth,n.srcHeight,i,r)&&(n.srcWidth=0,n.srcHeight=0),n}_requireTooManySrcTiles(e,i,r,t){const{tileInfo:n}=this.rasterInfo.storageInfo,a=Math.ceil(e/n.size[0])*Math.ceil(i/n.size[1]),s=e/r,l=i/t,o=Math.max(1,(r+t)/1024);return a>=Bt*o||s>Ie||l>Ie}_updateSourceDataInfo(e,i){i.srcWidth=0,i.srcHeight=0;const{rasterInfo:r}=this,t=r.spatialReference,{srcResolution:n,datumTransformation:a}=i,{pyramidLevel:s,pyramidResolution:l,excessiveReading:o}=xe(n,r,this.ioConfig.sampling);if(o)return;let c=i.srcExtent||Z(e,t,a);if(c==null)return;const u=r.transform;u&&(c=u.inverseTransform(c)),i.srcExtent=c;const{origin:d}=r.storageInfo,{width:h,height:p,ul:g}=mt(c,d,l,s);i.pyramidLevel=s,i.pyramidResolution=l,i.srcWidth=h,i.srcHeight=p,i.ul=g}_getRequestOptionsWithSliceId(e){return this.rasterInfo.multidimensionalInfo!=null&&e.sliceId==null&&(e={...e,sliceId:this.getSliceIndex(e.multidimensionalDefinition)}),e}_processIdentifyResult(e,i){const{srcLocation:r,position:t,pyramidLevel:n,useTransposedTile:a}=i,s=e.pixels[0].length/e.width/e.height;if(!(!e.mask||e.mask[t]))return{location:r,value:null};const{multidimensionalInfo:l}=this.rasterInfo;if(l==null||!a){const m=e.pixels.map(w=>w[t]),y={location:r,value:m,pyramidLevel:n},x=this._computeMagDirValues(m.map(w=>[w]));return x?.length&&(y.magdirValue=x.map(w=>w[0])),y}let o=e.pixels.map(m=>m.slice(t*s,t*s+s)),c=this._computeMagDirValues(o);const{requestSomeSlices:u,identifyOptions:d}=i;let h=Le(l,d.transposedVariableName);if(u){const m=Ae(h,d.multidimensionalDefinition,d.timeExtent);o=o.map(y=>m.map(x=>y[x])),c=c?.map(y=>m.map(x=>y[x])),h=m.map(y=>h[y])}const p=e.noDataValues||this.rasterInfo.noDataValue,g={pixels:o,pixelType:e.pixelType};let R;return p!=null&&($e(g,p),R=g.mask),{location:r,value:null,dataSeries:h.map((m,y)=>{const x={value:R?.[y]===0?null:o.map(w=>w[y]),multidimensionalDefinition:m.multidimensionalDefinition.map(w=>new ke({...w,isSlice:!0}))};return c?.length&&(x.magdirValue=[c[0][y],c[1][y]]),x}),pyramidLevel:n}}};function Ft(f,e,i){return Math.abs(f.x-e.x)<i&&Math.abs(f.y-e.y)<i}I([b()],_.prototype,"_rasterTileAlignmentInfo",void 0),I([b()],_.prototype,"_tileFetchQueue",void 0),I([b({readOnly:!0})],_.prototype,"_isGlobalWrappableSource",null),I([b({readOnly:!0})],_.prototype,"_hasNoneOrGCSShiftTransform",null),I([b()],_.prototype,"_openPromise",void 0),I([b()],_.prototype,"rasterJobHandler",null),I([b({readOnly:!0})],_.prototype,"rasterId",null),I([b(ve)],_.prototype,"url",null),I([b({type:String,json:{write:!0}})],_.prototype,"datasetName",void 0),I([b({type:String,json:{write:!0}})],_.prototype,"datasetFormat",void 0),I([b()],_.prototype,"hasUniqueSourceStorageInfo",void 0),I([b()],_.prototype,"rasterInfo",void 0),I([b()],_.prototype,"ioConfig",void 0),I([b()],_.prototype,"sourceJSON",void 0),_=I([ue("esri.layers.support.rasterDatasets.BaseRaster")],_);const Ct=40;let U=class extends _{constructor(){super(...arguments),this.datasetFormat="Function",this.tileType="Raster",this.rasterFunction=null,this._clippingGeometry=new Map}async fetchPixels(f,e,i,r={}){const{rasters:t,rasterIds:n}=this.primaryRasters;let a=!1;const{interpolation:s}=r,l=this.rasterFunction.flatWebGLFunctionChain?.hasFocalFunction;!r.requestRawData&&l&&(a=t.length===1&&!r.skipRasterFunction,r={...r,interpolation:"bilinear",requestRawData:a}),r.requestRawData&&t.length>1&&!this.hasUniqueSourceStorageInfo&&(a=!1,r={...r,requestRawData:!1});const o=t.map(x=>x.fetchPixels(f,e,i,r)),c=await Promise.all(o),u=c.map(x=>x.pixelBlock),d=a||r.requestRawData?c.map(x=>x.srcTilePixelSize):null;if(r.skipRasterFunction||u.every(x=>x==null))return c[0];const h=c.find(x=>x.pixelBlock!=null)?.extent??f;let p=this.rasterJobHandler?await this.rasterJobHandler.process({extent:h,primaryPixelBlocks:u,primaryPixelSizes:d,primaryRasterIds:n}):this.rasterFunction.process({extent:h,primaryPixelBlocks:u,primaryPixelSizes:d,primaryRasterIds:n});const{transformGrid:g}=c[0];if(!a||p==null||g==null){const x=r.noClip?null:this.getClippingGeometry(h.spatialReference);return!r.noClip&&p!=null&&x&&(p=await ce(p,h,x)),{...c[0],pixelBlock:p}}const R={rows:g.spacing[0],cols:g.spacing[1]};let m;this.rasterJobHandler?m=(await this.rasterJobHandler.mosaicAndTransform({srcPixelBlocks:[p],srcMosaicSize:{width:p.width,height:p.height},destDimension:{width:e,height:i},coefs:g.coefficients,sampleSpacing:R,projectDirections:!1,gcsGrid:null,isUV:!1,interpolation:s,alignmentInfo:void 0,blockWidths:null},r)).pixelBlock:m=Te(p,{width:e,height:i},g.coefficients,R,s);const y=r.noClip?null:this.getClippingGeometry(f.spatialReference);return r.noClip||m==null||y==null||(m=await ce(m,f,y)),{extent:f,srcExtent:c[0].srcExtent,pixelBlock:m}}getClippingGeometry(f){const e=this._clippingGeometry.get("0");if(!f||!e)return e;const i=zt(f);let r=this._clippingGeometry.get(i);return r!=null||(r=f.equals(e.spatialReference)?e:le(e,f),this._clippingGeometry.set(i,r)),r}async _open(f){const{rasterFunction:e}=this;e.isRoot=!0,this.primaryRasters?.rasters?.length?e.sourceRasters=this.primaryRasters.rasters:(this.primaryRasters=e.getPrimaryRasters(),this.rasterJobHandler&&this.primaryRasters.rasters?.forEach(o=>o.rasterJobHandler=this.rasterJobHandler));const{rasters:i,rasterIds:r}=this.primaryRasters,t=i.map(o=>o.rasterInfo?void 0:o.open(f));await Promise.all(t);const n=i.map(({rasterInfo:o})=>o),a=e.bind({rasterInfos:n,rasterIds:r});if(e.rawSourceRasterInfos=n,!a.success||n.length===0)throw new H("raster-function:open",`cannot bind the function: ${a.error??""}`);const s=e.functionName==="Table"?e:e.functionArguments?.raster;s?.functionName==="Table"&&(e.rasterInfo.attributeTable=He.fromJSON(s.functionArguments.attributeTableAsRecordSet)),await this.syncJobHandler();const l=n[0];this.hasUniqueSourceStorageInfo=n.length===1||n.slice(1).every(o=>Dt(o,l)),this.set("sourceJSON",i[0].sourceJSON),this.set("rasterInfo",e.rasterInfo),await this._updateClipGeometry()}async syncJobHandler(){return this.rasterJobHandler?.updateRasterFunction(this.rasterFunction)}async _updateClipGeometry(){const f=this.rasterFunction.getClippingGeometries()[0];let e=f?.clippingGeometry;if(e&&f.clippingType==="inside"){const{extent:i}=this.rasterInfo,r=await te(()=>import("./densifyOperator-CknJhA0u.js").then(a=>a.d),__vite__mapDeps([0,1,2,3,4,5,6,7,8,9,10,11])),t=await te(()=>import("./differenceOperator-DHJD9M-i.js").then(a=>a.d),__vite__mapDeps([12,3,4,5,6,7,1,2,8,9,11]));let n=r.execute(Me.fromExtent(i),2*(i.width+i.height)/Ct);n=le(n,e.spatialReference),e=t.execute(n,e)}this._clippingGeometry.clear(),e&&this._clippingGeometry.set("0",e)}};function Dt(f,e){const{storageInfo:i,pixelSize:r,spatialReference:t,extent:n}=f,{storageInfo:a,pixelSize:s,spatialReference:l,extent:o}=e;return r.x===s.x&&r.y===s.y&&t.equals(l)&&n.equals(o)&&i.blockHeight===a.blockHeight&&i.blockWidth===a.blockWidth&&i.maximumPyramidLevel===a.maximumPyramidLevel&&i.firstPyramidLevel===a.firstPyramidLevel&&i.pyramidBlockWidth===a.pyramidBlockWidth&&i.pyramidBlockHeight===a.pyramidBlockHeight&&i.pyramidScalingFactor===a.pyramidScalingFactor}function zt(f){return String(f.wkid??f.wkt??f.wkt2)}I([b({type:String,json:{write:!0}})],U.prototype,"datasetFormat",void 0),I([b()],U.prototype,"tileType",void 0),I([b()],U.prototype,"rasterFunction",void 0),I([b()],U.prototype,"primaryRasters",void 0),U=I([ue("esri.layers.support.rasterDatasets.FunctionRaster")],U);const Re=1e3,qt=f=>{const e=f;let i=class extends e{constructor(...t){super(...t),this._isConstructedFromFunctionRaster=!1,this.bandIds=null,this.copyright=null,this.interpolation=null,this.multidimensionalSubset=null,this.raster=null,this.serviceRasterInfo=null,this.sourceJSON=null,this.spatialReference=null,this.symbolizer=null,this._isConstructedFromFunctionRaster=N(t[0]?.raster)}destroy(){this._shutdownJobHandler()}get fullExtent(){return this.serviceRasterInfo?.extent}set multidimensionalDefinition(t){this._set("multidimensionalDefinition",t),this.updateRenderer()}set rasterFunction(t){t?.functionName?.toLowerCase()==="none"&&(t=void 0),this._set("rasterFunction",t),this.updateRasterFunction()}set url(t){this._set("url",be(t,ae.getLogger(this)))}get renderer(){if(this.type!=="imagery-tile")return this.internalRenderer;const{activePresetRendererName:t,presetRenderers:n}=this;return t?n?.find(({name:s})=>s===t)?.renderer.clone():this.internalRenderer}set renderer(t){this.type==="imagery-tile"&&(this.activePresetRendererName=null),this.internalRenderer=t}set internalRenderer(t){t==null&&this.rasterFunction==null?this._configDefaultRenderer("override"):(this._set("internalRenderer",t),this.updateRenderer())}readRenderer(t,n,a){const s=n?.layerDefinition?.drawingInfo?.renderer;return Ve(s,a)||void 0}async computeStatisticsHistograms(t,n){await this.load(n),t=Y(Ue,t).clone();const{serviceRasterInfo:a}=this;if(a==null)throw new H("imagery-tile-mixin:compute-statistics-histograms","serviceRasterInfo must be specified");const{geometry:s}=t;if(s==null)throw new H("imagery-tile-mixin:compute-statistics-histograms","geometry must be specified");let l=s;const{spatialReference:o}=a;if(!s.spatialReference.equals(o)){await oe();const m=s.type==="extent"?Z(s,o):le(s,o);if(m==null)throw new H("imagery-tile-mixin:compute-statistics-histograms","geometry cannot be projected to the data source");l=m}const c=t.pixelSize??new C({x:a.pixelSize.x,y:a.pixelSize.y,spatialReference:o}),{extent:u,width:d,height:h}=Rt(a,l,c),p=await this.fetchPixels(u,d,h,{...n,interpolation:"nearest"});if(p.pixelBlock==null)throw new H("imagery-tile-mixin:compute-statistics-histograms","failed to fetch pixels");const g=await ce(p.pixelBlock,u,l),R=this._rasterJobHandler;return R?R.computeStatisticsHistograms({pixelBlock:g},n):ft(g)}normalizeRasterFetchOptions(t){const{multidimensionalInfo:n}=this.serviceRasterInfo??{};if(n==null)return t;const a=Qe({rasterInfo:this.raster.rasterInfo,multidimensionalDefinition:t.multidimensionalDefinition||this.multidimensionalDefinition,timeExtent:t.timeExtent??this.timeExtent,multidimensionalSubset:this.multidimensionalSubset});return{...t,multidimensionalDefinition:a,timeExtent:void 0}}async updateRasterFunction(){return this.loaded&&this.type==="imagery-tile"&&(this.rasterFunction||this._cachedRasterFunctionJson)&&JSON.stringify(this.rasterFunction)!==JSON.stringify(this._cachedRasterFunctionJson)?(this._cachedRasterFunctionJson=this.rasterFunction?.toJSON(),this._rasterFunctionUpdatePromise=this._updateRasterFunction(),this._rasterFunctionUpdatePromise):this._rasterFunctionUpdatePromise}async updateRenderer(){const{loaded:t,symbolizer:n,renderer:a}=this;if(!t||!n||!a)return;const{rasterInfo:s}=this.raster,l=de(s,{multidimensionalDefinition:this.multidimensionalDefinition,multidimensionalSubset:this.multidimensionalSubset}),o=l?.name,c=me(s,o);return this._updateSymbolizer(n,a,o,c)}async applyRenderer(t,n,a){const s=t?.pixelBlock;if(!(s!=null&&s.pixels&&s.pixels.length>0))return null;await this.updateRenderer();const l=this.bandIds??[],{pixelBlock:o}=await this._symbolize({pixelData:t,simpleStretchParams:n,bandIds:l,symbolizer:this.symbolizer},a);return o}getRawDisplayBandIds(){let{bandIds:t,raster:n}=this;if(this.rasterFunction&&N(n)){const a=n.rasterFunction.rawInputBandIds;t=t?.length&&a?.length&&n.rasterInfo.bandCount!==1?t.map(s=>a[Math.min(s,a.length-1)]):a}return t&&t.length>3&&t.every((a,s)=>a===s)?null:t}getTileUrl(t,n,a){return this.raster.datasetFormat==="RasterTileServer"?`${this.url}/tile/${t}/${n}/${a}`:""}getCompatibleTileInfo(t,n,a=!1){if(!this.loaded||n==null)return null;if(a&&t.equals(this.spatialReference))return this.tileInfo;const s=Oe(t);return ee.create({size:256,spatialReference:t,origin:s?{x:s.origin[0],y:s.origin[1]}:{x:n.xmin,y:n.ymax}})}getCompatibleFullExtent(t){return this.loaded?(this._compatibleFullExtent?.spatialReference.equals(t)||(this._compatibleFullExtent=this.raster.computeExtent(t)),this._compatibleFullExtent):null}async fetchTile(t,n,a,s={}){if(r(this),s.requestAsImageElement){const o=this.getTileUrl(t,n,a);return we(o,{responseType:"image",query:{...this.refreshParameters,...this.raster.ioConfig.customFetchParameters},signal:s.signal}).then(c=>c.data)}const{serviceRasterInfo:l}=this;if(l.multidimensionalInfo!=null&&(s=this.normalizeRasterFetchOptions(s)).multidimensionalDefinition==null){const o=s.tileInfo||l.storageInfo.tileInfo,c=this.raster.getTileExtentFromTileInfo(t,n,a,o);if(c)return{extent:c,pixelBlock:null}}return await this._initJobHandler(),await this.updateRasterFunction(),this.renderer?.type==="raster-shaded-relief"&&(s={...s,buffer:{cols:1,rows:1}}),this.raster.fetchTile(t,n,a,s)}async fetchPixels(t,n,a,s={}){if(this.serviceRasterInfo.multidimensionalInfo!=null&&(s=this.normalizeRasterFetchOptions(s)).multidimensionalDefinition==null)return{extent:t,pixelBlock:null};await this._initJobHandler(),await this.updateRasterFunction(),n=Math.round(n),a=Math.round(a);const l=await this.raster.fetchPixels(t,n,a,s);return s.bandIds?.length&&!this.raster.rasterInfo.storageInfo.isBsqTile&&(l.pixelBlock=l.pixelBlock?.extractBands(s.bandIds)),l}async getSamples(t,n){if(await this.load(),(t=Y(Xe,t).clone()).interpolation&&t.interpolation!=="nearest")throw new H("imagery-tile-mixin:get-samples","only nearest interpolation is currently supported");const a=t.mosaicRule?.multidimensionalDefinition,s={...n,multidimensionalDefinition:a},l=(await this._getSampleLocations(t)).map(c=>this.identify(c,s).then(u=>(u.location=c,u))),o=(await Promise.all(l)).flatMap((c,u)=>this._convertRasterIdentifyResultToSample(c,u));return new Ke({samples:o})}async identify(t,n={}){await this.load(),t=Y(C,t).clone().normalize();const{raster:a,serviceRasterInfo:s}=this;if(s?.multidimensionalInfo!=null&&!(s.hasMultidimensionalTranspose&&!(!Se(n.multidimensionalDefinition)&&!n.transposedVariableName))&&(n=this.normalizeRasterFetchOptions(n)).multidimensionalDefinition==null)return{location:t,value:null};const l=this.multidimensionalSubset?.areaOfInterest;if(l&&!l.contains(t))throw new H("imagery-tile-mixin:identify","the request cannot be fulfilled when falling outside of the multidimensional subset");let o;if(this.serviceRasterInfo?.storageInfo.isBsqTile){const c=N(a)?this.getRawDisplayBandIds():this.bandIds;o=c?.length?c:void 0}return a.identify(t,{...n,bandIds:o})}hasStandardTime(){const t=this.serviceRasterInfo?.multidimensionalInfo;if(t==null||this.serviceRasterInfo?.dataType!=="standard-time")return!1;const n=this.multidimensionalDefinition,a=n?.[0]?.variableName;return t.variables.some(s=>s.name===a&&(!n?.[0].dimensionName||s.dimensions.some(l=>l.name==="StdTime")))}getStandardTimeValue(t){return new Date(Ye(t)).toISOString()}getMultidimensionalSubsetVariables(t){const n=t??this.serviceRasterInfo?.multidimensionalInfo;return Ze(this.multidimensionalSubset,n)}_configDefaultSettings(){this._configDefaultInterpolation(),this.multidimensionalDefinition||(this.multidimensionalDefinition=et(this.raster.rasterInfo,{multidimensionalSubset:this.multidimensionalSubset})),this.rasterFunction&&N(this.raster)&&(this._cachedRasterFunctionJson=this.rasterFunction.toJSON()),this._configDefaultRenderer()}async _initJobHandler(){if(!this._rasterJobHandler)return super._initJobHandler().then(async()=>{if(!this._rasterJobHandler)return;r(this);const{raster:t}=this;t.rasterJobHandler=this._rasterJobHandler,N(t)&&t.syncJobHandler(),this.rasterFunction&&await this.updateRasterFunction().catch(()=>{}),this.renderer&&this.updateRenderer()}).catch(()=>{})}_shutdownJobHandler(){super._shutdownJobHandler(),this.raster&&(this.raster.rasterJobHandler=null)}async _getSampleLocations(t){const{geometry:n}=t;if(n.type==="point")return[n];const{spatialReference:a,type:s}=n;if(s==="multipoint")return n.points.map(m=>new C({x:m[0],y:m[1],spatialReference:a}));if(s==="polyline"){let m=n;if(t.sampleCount||t.sampleDistance){const y=await te(()=>import("./densifyOperator-CknJhA0u.js").then(B=>B.d),__vite__mapDeps([0,1,2,3,4,5,6,7,8,9,10,11])),x=(await te(async()=>{const{execute:B}=await import("./lengthOperator-ivQu0sNN.js").then(z=>z.l);return{execute:B}},__vite__mapDeps([13,1,2,3,5,4,6,7,8,9,11]))).execute(n,{unit:"meters"}),w=Math.min(t.sampleCount||100,Re);let v=t.sampleDistance;v||(v=x/(w+(m.paths[0].length===2?1:0))),m=y.execute(n,v,{unit:"meters"})}return m.paths.flatMap(y=>y.map(x=>new C({x:x[0],y:x[1],spatialReference:a})))}const l=Math.min(t.sampleCount||100,Re),o=n.type==="extent",c=o?n:n.extent,u=Math.sqrt(c.width*c.height/l),d=c.height/u,h=c.width/u,{xmin:p,ymax:g}=c,R=[];for(let m=0;m<d;m++)for(let y=0;y<h;y++){const x=new C({x:p+(y+.5)*u,y:g-(m+.5)*u,spatialReference:a});(o||n.contains(x))&&R.push(x)}return R}_configDefaultInterpolation(){if(this.interpolation==null){r(this);const{raster:t}=this,n=tt(t.rasterInfo,t.tileType,this.sourceJSON?.defaultResamplingMethod);this._set("interpolation",n)}}_configDefaultRenderer(t="no"){r(this);const{rasterInfo:n}=this.raster,a=de(n,{multidimensionalDefinition:this.multidimensionalDefinition,multidimensionalSubset:this.multidimensionalSubset}),s=a?.name,l=it({variableName:s,rasterFunctionName:this.rasterFunction?.functionName,presetRenderers:this.presetRenderers});if(!this.bandIds&&n.bandCount>1&&(this.bandIds=l?.bandIds??nt(n)),!this.renderer||t==="override"){const d=rt(this.raster),h=l?.renderer??pe(n,{bandIds:this.bandIds,variableName:s,rasterFunctionColorRamp:d}),p=n.statistics,g=p&&p.length>0?p[0]:null,R=g?.max??0,m=g?.min??0;this.raster.datasetFormat==="WCSServer"&&h.type==="raster-stretch"&&(R>1e24||m<-1e24)&&(h.dynamicRangeAdjustment=!0,h.customStatistics=null,h.stretchType==="none"&&(h.stretchType="min-max")),this.renderer=h}const o=st({...this.renderer.toJSON(),variableName:s}),c=me(n,s);this.symbolizer?(this.symbolizer.rendererJSON=o,this.symbolizer.rasterInfo=c):this.symbolizer=new dt({rendererJSON:o,rasterInfo:c});const u=this.symbolizer.bind();if(u.success){if(t==="auto"){const{colormap:d}=this.raster.rasterInfo,h=this.renderer;if(d!=null&&h.type==="raster-colormap"){const p=pe(this.raster.rasterInfo);JSON.stringify(p)!==JSON.stringify(h)&&this._configDefaultRenderer("override")}else if(h.type==="raster-stretch"){const p=this.bandIds?.length,g=h.customStatistics?.length;!h.dynamicRangeAdjustment&&g&&p&&g!==p&&this._configDefaultRenderer("override")}}}else ae.getLogger(this).warn("imagery-tile-mixin",u.error||"The given renderer is not supported by the layer."),t==="auto"&&this._configDefaultRenderer("override")}async _updateRasterFunction(){if(this._isConstructedFromFunctionRaster&&N(this.raster)){const u=this.raster.rasterFunction.toJSON();return void(!this.rasterFunction&&u&&this._set("rasterFunction",fe.fromJSON(u)))}let t,n=this.raster,a=!1;N(n)?(t=n.primaryRasters.rasters,n=t[0],a=!0):t=[n];const{rasterFunction:s}=this;if(s){const u={raster:n};t.length>1&&t.forEach(p=>u[p.url]=p);const d=bt(s.functionDefinition?.toJSON()??s.toJSON(),u),h=new U({rasterFunction:d});h.rasterJobHandler=this._rasterJobHandler,await h.open(),this.raster=h}else this.raster=n,await n.open();if(this._cachedRendererJson=void 0,!a&&!s)return;const{bandIds:l}=this,{bandCount:o}=this.raster.rasterInfo,c=l?.length?l.some(u=>u>=o):o>=3;l&&(c||this.renderer&&this.renderer.type!=="raster-stretch")&&this._set("bandIds",null),this._configDefaultRenderer("auto")}_convertRasterIdentifyResultToSample(t,n){const{rasterInfo:a}=this.raster,s=a.storageInfo.pyramidScalingFactor**(t.pyramidLevel??0),l=(a.pixelSize.x+a.pixelSize.y)/2*s;if(!t.dataSeries?.length)return[new ye({location:t.location,pixelValue:t.value,locationId:n,resolution:l})];const o=[];return t.dataSeries.forEach(({value:c,multidimensionalDefinition:u},d)=>{const h={Variables:u[0].variableName,Dimensions:u.flatMap(({dimensionName:g})=>g).join(",")};for(const{dimensionName:g,values:R}of u){h[g]=Array.isArray(R[0])?R[0][0]:R[0];const m=R[R.length-1];h[`${g}_Max`]=Array.isArray(m)?m[m.length-1]:m}const p=new ye({location:t.location,pixelValue:c,rasterId:d,locationId:n,resolution:l,attributes:h});o.push(p)}),o}};function r(t){if(!t.raster||!t.serviceRasterInfo)throw new H("imagery-tile","no raster")}return I([b({clonable:!1})],i.prototype,"_cachedRasterFunctionJson",void 0),I([b({clonable:!1})],i.prototype,"_compatibleFullExtent",void 0),I([b({clonable:!1})],i.prototype,"_isConstructedFromFunctionRaster",void 0),I([b({clonable:!1})],i.prototype,"_rasterFunctionUpdatePromise",void 0),I([b({type:[Je],json:{write:{overridePolicy(){return{enabled:!this.loaded||this.raster.tileType==="Raster"||this.bandIds?.join(",")!=="0,1,2"}}}}})],i.prototype,"bandIds",void 0),I([b({json:{origins:{service:{read:{source:"copyrightText"}}}}})],i.prototype,"copyright",void 0),I([b({json:{read:!1}})],i.prototype,"fullExtent",null),I([b({json:{write:{overridePolicy(){return{enabled:!this.loaded||this.raster.tileType==="Raster"||this.interpolation!=="bilinear"}}}}}),Ne(ht)],i.prototype,"interpolation",void 0),I([b()],i.prototype,"ioConfig",void 0),I([b({type:[ke],json:{write:!0}})],i.prototype,"multidimensionalDefinition",null),I([b({type:qe,json:{write:!0}})],i.prototype,"multidimensionalSubset",void 0),I([b()],i.prototype,"raster",void 0),I([b({type:fe})],i.prototype,"rasterFunction",null),I([b()],i.prototype,"serviceRasterInfo",void 0),I([b()],i.prototype,"sourceJSON",void 0),I([b({readOnly:!0,type:_e,json:{read:!1}})],i.prototype,"spatialReference",void 0),I([b({type:ee})],i.prototype,"tileInfo",void 0),I([b(ve)],i.prototype,"url",null),I([b()],i.prototype,"renderer",null),I([b({types:je,json:{name:"layerDefinition.drawingInfo.renderer",write:{overridePolicy(){const t=this.renderer?.type==="raster-stretch"&&this.renderer.stretchType==="none"&&!this.renderer.useGamma;return{enabled:!this.loaded||this.raster.tileType==="Raster"||!t}}},origins:{"web-scene":{types:Ge,name:"layerDefinition.drawingInfo.renderer",write:{overridePolicy:t=>({enabled:t&&t.type!=="vector-field"})}}}}})],i.prototype,"internalRenderer",null),I([Ee("internalRenderer")],i.prototype,"readRenderer",null),I([b({clonable:!1})],i.prototype,"symbolizer",void 0),i=I([ue("esri.layers.mixins.ImageryTileMixin")],i),i};function ie(f,e){if(!f||!e)return[];let i=e;e.includes("/")?(i=e.slice(0,e.indexOf("/")),e=e.slice(e.indexOf("/")+1)):e="";const r=[];if(e){const n=ie(f,i);for(let a=0;a<n.length;a++)ie(n[a],e).forEach(s=>r.push(s));return r}const t=f.getElementsByTagNameNS("*",i);if(!t||t.length===0)return[];for(let n=0;n<t.length;n++)r.push(t[n]||t.item(n));return r}function Be(f,e){if(!f||!e)return null;let i=e;e.includes("/")?(i=e.slice(0,e.indexOf("/")),e=e.slice(e.indexOf("/")+1)):e="";const r=ie(f,i);return r.length>0?e?Be(r[0],e):r[0]:null}function Pe(f,e=null){const i=e?Be(f,e):f;let r;return i?(r=i.textContent||i.nodeValue,r?r.trim():null):null}function $t(f,e){const i=ie(f,e),r=[];let t;for(let n=0;n<i.length;n++)t=i[n].textContent||i[n].nodeValue,t&&(t=t.trim(),t!==""&&r.push(t));return r}function Gt(f,e=null){return Pe(f,e)?.split(" ").map(r=>Number(r))??[]}function jt(f,e){return $t(f,e).map(i=>Number(i))}function Vt(f,e){const i=Pe(f,e);return Number(i)}function Ut(f,e){const i=f?.nodeName?.toLowerCase(),r=e.toLowerCase();return i.slice(i.lastIndexOf(":")+1)===r}function Qt(f){return f.nodeName.slice(f.nodeName.lastIndexOf(":")+1)}export{_ as X,qt as a,Qt as c,Be as e,Ut as i,$t as l,U as m,ie as n,Vt as o,Gt as r,Pe as t,jt as u};
