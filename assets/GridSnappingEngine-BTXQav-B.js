import{hj as X,cW as W,V as U,aB as E,iH as j,aC as Y,nH as D,a9 as I,c4 as F,nI as L,hw as V,nJ as T,bl as q,fb as B,nK as J,nL as _,e as l,m as c,h as K}from"./index-FjkLmFqq.js";import{M as N,R as Q,O as S,P as k,Q as z,S as A,T as Z}from"./euclideanLengthMeasurementUtils-A0_x-TQ2.js";import"./utils-DecFH9K9.js";import"./geometry2dUtils-DpG_6IxJ.js";import"./geodeticLengthOperator-DkJJgyg3.js";import"./geodeticCurveType-CirnHLSB.js";const ee=50,te=5;function re(e,r){return Math.log(e)/Math.log(r)}function ne(e,r,t){const i=e===1?10:e;return i**(t?Math.round(re(ee/r,i)):0)}function ie(e){const{isGeographic:r,isWebMercator:t}=e;return!r&&!t}function se(e,r,t){const i=typeof e=="number"?null:e,n=t??i?.spatialReference;if(n==null||!X(n)||ie(n))return W(n);let s=i?.x??e,a=i?.y??r;const h=1/Math.sqrt(2);let p=s+h,f=a+h;const{isWebMercator:g,isGeographic:R}=n;let w=R&&!N(n)?U.WGS84:n;if(g){let u=new E({x:s,y:a,spatialReference:n});j(u,!0,u),s=u.x,a=u.y,u=new E({x:p,y:f,spatialReference:n}),j(u,!0,u),p=u.x,f=u.y,w=U.WGS84}const M=new Y({paths:[[[s,a],[p,f]]],spatialReference:w}),b=D(M,10);let d;try{[d]=Q([b],"meters")}catch{return W(n)}return d}let o=class extends I{constructor(e){super(e),this.options=null}destroy(){this._set("options",null)}get grid(){return this.view.grid}get effectiveViewRotation(){return this.grid?.rotateWithMap?0:F(this.view.rotation??0)}get gridRotation(){return F(this.grid?.rotation??0)}get gridCenter(){const{spatialReference:e,grid:r}=this;if(!r||!e||!L(r.center.spatialReference,e))return null;try{const t=V(r.center,e),i=e.isWrappable&&this.view?.center!=null?T(t.x,this.view.center.x,e):t.x;return S(i,t.y,t.z)}catch(t){return q.getLogger(this).errorOnce("Grid Snapping - Failed to project grid center.",t),null}}get offsetScaleFactor(){const{pixelsPerStride:e,grid:r}=this;if(!r||!e)return 1;const{majorLineInterval:t,dynamicScaling:i}=r;return t<1?null:ne(t,e,i)}get spatialReference(){return this.view.spatialReference}get gridMetersPerStride(){const{grid:e}=this;return e?B(e.spacing,e.units,"meters"):null}get viewMetersPerPixel(){const{viewMetersPerSRUnit:e}=this;return e==null?null:e*J(this.view.scale,this.view.spatialReference)}get viewMetersPerSRUnit(){const{spatialReference:e}=this.view;return this.gridCenter?se(this.gridCenter[0],this.gridCenter[1],e):null}get pixelsPerStride(){const{gridMetersPerStride:e,viewMetersPerPixel:r}=this;return r&&e?e/r:null}get updating(){return this.grid!=null&&this.spatialReference!=null&&this.viewMetersPerSRUnit==null}async fetchCandidates(e,r,t){const{options:i,view:n}=this;if(!i?.effectiveGridEnabled||!n.grid||t.feature?.attributes&&k in t.feature.attributes)return[];const s=t.coordinateHelper.arrayToPoint(e),a=i.distance*(t.pointer==="touch"?i.touchSensitivityMultiplier:1);return this.fetchCandidatesSync(s,a)}fetchCandidatesSync(e,r){const t=[],{grid:i,effectiveViewRotation:n,gridRotation:s,gridCenter:a,viewMetersPerPixel:h,viewMetersPerSRUnit:p,offsetScaleFactor:f,spatialReference:g,gridMetersPerStride:R,pixelsPerStride:w}=this;if(!(i&&h&&p&&a&&g&&f&&R&&w)||!i.dynamicScaling&&w<te||!L(e.spatialReference,g))return t;const M=V(e,g),b=S(M.x,M.y,M.z),d=v(b,-s,a,-n),u=R/p*f,y=ae(d,u,a),{shouldSnapX:P,shouldSnapY:x}=oe(y,d,r,h,p);if(!P&&!x)return[];const O=S((P?y:d)[0],(x?y:d)[1]),m=v(O,s,a,n),G=v(y,s,a,n);if(x){const $=H(y,d,u,"y"),C=v($,s,a,n);t.push(new z({lineStart:G,lineEnd:C,targetPoint:m,isDraped:!1}))}if(P){const $=H(y,d,u,"x"),C=v($,s,a,n);t.push(new z({lineStart:G,lineEnd:C,targetPoint:m,isDraped:!1}))}return P&&x&&t.push(new A(m,t[0],t[1],!1)),t}};l([c({constructOnly:!0})],o.prototype,"view",void 0),l([c()],o.prototype,"options",void 0),l([c()],o.prototype,"grid",null),l([c()],o.prototype,"effectiveViewRotation",null),l([c()],o.prototype,"gridRotation",null),l([c()],o.prototype,"gridCenter",null),l([c()],o.prototype,"offsetScaleFactor",null),l([c()],o.prototype,"spatialReference",null),l([c()],o.prototype,"gridMetersPerStride",null),l([c()],o.prototype,"viewMetersPerPixel",null),l([c()],o.prototype,"viewMetersPerSRUnit",null),l([c()],o.prototype,"pixelsPerStride",null),l([c()],o.prototype,"updating",null),o=l([K("esri.views.interactive.snapping.GridSnappingEngine")],o);const v=(e,r,t,i)=>{const n=Z(e[0],e[1],e[2]);return _(n,_(n,n,t,r),t,i)},ae=(e,r,t)=>{const i=(e[0]-t[0])/r,n=(e[1]-t[1])/r,s=Math.trunc(i),a=Math.trunc(n),h=Math.round(i%1),p=Math.round(n%1),f=t[0]+(s+h)*r,g=t[1]+(a+p)*r;return S(f,g)},oe=(e,r,t,i,n)=>{if(i<=0)return{shouldSnapX:!1,shouldSnapY:!1};const s=(e[0]-r[0])/i,a=(e[1]-r[1])/i;return{shouldSnapX:Math.abs(s*n)<t,shouldSnapY:Math.abs(a*n)<t}},H=(e,r,t,i)=>{if(i==="y"){const s=r[0]>e[0]?1:-1;return S(e[0]+t*s,e[1])}const n=r[1]>e[1]?1:-1;return S(e[0],e[1]+t*n)};export{o as GridSnappingEngine};
